<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>librdkafka: RdKafka::KafkaConsumer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">librdkafka
   </div>
   <div id="projectbrief">The Apache Kafka C/C++ client library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classRdKafka_1_1KafkaConsumer.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">RdKafka::KafkaConsumer Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>High-level <a class="el" href="classRdKafka_1_1KafkaConsumer.html" title="High-level KafkaConsumer (for brokers 0.9 and later) ">KafkaConsumer</a> (for brokers 0.9 and later)  
 <a href="classRdKafka_1_1KafkaConsumer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rdkafkacpp_8h_source.html">rdkafkacpp.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RdKafka::KafkaConsumer:</div>
<div class="dyncontent">
<div class="center"><img src="classRdKafka_1_1KafkaConsumer__inherit__graph.png" border="0" usemap="#RdKafka_1_1KafkaConsumer_inherit__map" alt="Inheritance graph"/></div>
<map name="RdKafka_1_1KafkaConsumer_inherit__map" id="RdKafka_1_1KafkaConsumer_inherit__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for RdKafka::KafkaConsumer:</div>
<div class="dyncontent">
<div class="center"><img src="classRdKafka_1_1KafkaConsumer__coll__graph.png" border="0" usemap="#RdKafka_1_1KafkaConsumer_coll__map" alt="Collaboration graph"/></div>
<map name="RdKafka_1_1KafkaConsumer_coll__map" id="RdKafka_1_1KafkaConsumer_coll__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afd22626a2b370f378272e30411df6f78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd22626a2b370f378272e30411df6f78"></a>
virtual ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#afd22626a2b370f378272e30411df6f78">assignment</a> (std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">RdKafka::TopicPartition</a> * &gt; &amp;partitions)=0</td></tr>
<tr class="memdesc:afd22626a2b370f378272e30411df6f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current partition assignment as set by <a class="el" href="classRdKafka_1_1KafkaConsumer.html#af3f872bcb7d46febbaea63518f854b46" title="Update the assignment set to partitions. ">RdKafka::KafkaConsumer::assign()</a> <br/></td></tr>
<tr class="separator:afd22626a2b370f378272e30411df6f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470f95d195c1c0dc9466040cdf1ec12d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a470f95d195c1c0dc9466040cdf1ec12d"></a>
virtual ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#a470f95d195c1c0dc9466040cdf1ec12d">subscription</a> (std::vector&lt; std::string &gt; &amp;topics)=0</td></tr>
<tr class="memdesc:a470f95d195c1c0dc9466040cdf1ec12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current subscription as set by <a class="el" href="classRdKafka_1_1KafkaConsumer.html#a7404297cecc9be656026c6c6154ce2bd" title="Update the subscription set to topics. ">RdKafka::KafkaConsumer::subscribe()</a> <br/></td></tr>
<tr class="separator:a470f95d195c1c0dc9466040cdf1ec12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7404297cecc9be656026c6c6154ce2bd"><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#a7404297cecc9be656026c6c6154ce2bd">subscribe</a> (const std::vector&lt; std::string &gt; &amp;topics)=0</td></tr>
<tr class="memdesc:a7404297cecc9be656026c6c6154ce2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the subscription set to <code>topics</code>.  <a href="#a7404297cecc9be656026c6c6154ce2bd">More...</a><br/></td></tr>
<tr class="separator:a7404297cecc9be656026c6c6154ce2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933d7e1d8bceab2422463ee8b335f15b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a933d7e1d8bceab2422463ee8b335f15b"></a>
virtual ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#a933d7e1d8bceab2422463ee8b335f15b">unsubscribe</a> ()=0</td></tr>
<tr class="memdesc:a933d7e1d8bceab2422463ee8b335f15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe from the current subscription set. <br/></td></tr>
<tr class="separator:a933d7e1d8bceab2422463ee8b335f15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f872bcb7d46febbaea63518f854b46"><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#af3f872bcb7d46febbaea63518f854b46">assign</a> (const std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;partitions)=0</td></tr>
<tr class="memdesc:af3f872bcb7d46febbaea63518f854b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the assignment set to <code>partitions</code>.  <a href="#af3f872bcb7d46febbaea63518f854b46">More...</a><br/></td></tr>
<tr class="separator:af3f872bcb7d46febbaea63518f854b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21dc83bc3eb00e2b4e0f6373244976b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21dc83bc3eb00e2b4e0f6373244976b6"></a>
virtual ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#a21dc83bc3eb00e2b4e0f6373244976b6">unassign</a> ()=0</td></tr>
<tr class="memdesc:a21dc83bc3eb00e2b4e0f6373244976b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop consumption and remove the current assignment. <br/></td></tr>
<tr class="separator:a21dc83bc3eb00e2b4e0f6373244976b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc106f1c3b99767a0930a9cf8cabf84"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRdKafka_1_1Message.html">Message</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#a7dc106f1c3b99767a0930a9cf8cabf84">consume</a> (int timeout_ms)=0</td></tr>
<tr class="memdesc:a7dc106f1c3b99767a0930a9cf8cabf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consume message or get error event, triggers callbacks.  <a href="#a7dc106f1c3b99767a0930a9cf8cabf84">More...</a><br/></td></tr>
<tr class="separator:a7dc106f1c3b99767a0930a9cf8cabf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c421bf2b44509704ad3d9e785c5b15c"><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#a1c421bf2b44509704ad3d9e785c5b15c">commitSync</a> ()=0</td></tr>
<tr class="memdesc:a1c421bf2b44509704ad3d9e785c5b15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit offsets for the current assignment.  <a href="#a1c421bf2b44509704ad3d9e785c5b15c">More...</a><br/></td></tr>
<tr class="separator:a1c421bf2b44509704ad3d9e785c5b15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d68b1b8d21dc26499938cb6e529f928"><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#a6d68b1b8d21dc26499938cb6e529f928">commitAsync</a> ()=0</td></tr>
<tr class="memdesc:a6d68b1b8d21dc26499938cb6e529f928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous version of RdKafka::KafkaConsumer::CommitSync()  <a href="#a6d68b1b8d21dc26499938cb6e529f928">More...</a><br/></td></tr>
<tr class="separator:a6d68b1b8d21dc26499938cb6e529f928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d1b4fcadea749b774ab1cdd62de2d1"><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#ac5d1b4fcadea749b774ab1cdd62de2d1">commitSync</a> (<a class="el" href="classRdKafka_1_1Message.html">Message</a> *message)=0</td></tr>
<tr class="memdesc:ac5d1b4fcadea749b774ab1cdd62de2d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit offset for a single topic+partition based on <code>message</code>.  <a href="#ac5d1b4fcadea749b774ab1cdd62de2d1">More...</a><br/></td></tr>
<tr class="separator:ac5d1b4fcadea749b774ab1cdd62de2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278db6d20ebcaf501af9487c0957d57f"><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#a278db6d20ebcaf501af9487c0957d57f">commitAsync</a> (<a class="el" href="classRdKafka_1_1Message.html">Message</a> *message)=0</td></tr>
<tr class="memdesc:a278db6d20ebcaf501af9487c0957d57f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit offset for a single topic+partition based on <code>message</code>.  <a href="#a278db6d20ebcaf501af9487c0957d57f">More...</a><br/></td></tr>
<tr class="separator:a278db6d20ebcaf501af9487c0957d57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892f5ec51f898b67a19d892b9ab08177"><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#a892f5ec51f898b67a19d892b9ab08177">commitSync</a> (std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;offsets)=0</td></tr>
<tr class="memdesc:a892f5ec51f898b67a19d892b9ab08177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit offsets for the provided list of partitions.  <a href="#a892f5ec51f898b67a19d892b9ab08177">More...</a><br/></td></tr>
<tr class="separator:a892f5ec51f898b67a19d892b9ab08177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a2c7639521e0c9eb25c3417921e318"><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#a66a2c7639521e0c9eb25c3417921e318">commitAsync</a> (const std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;offsets)=0</td></tr>
<tr class="memdesc:a66a2c7639521e0c9eb25c3417921e318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit offset for the provided list of partitions.  <a href="#a66a2c7639521e0c9eb25c3417921e318">More...</a><br/></td></tr>
<tr class="separator:a66a2c7639521e0c9eb25c3417921e318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6791befdd7d705be26e5ed69cf219376"><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#a6791befdd7d705be26e5ed69cf219376">commitSync</a> (<a class="el" href="classRdKafka_1_1OffsetCommitCb.html">OffsetCommitCb</a> *offset_commit_cb)=0</td></tr>
<tr class="memdesc:a6791befdd7d705be26e5ed69cf219376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit offsets for the current assignment.  <a href="#a6791befdd7d705be26e5ed69cf219376">More...</a><br/></td></tr>
<tr class="separator:a6791befdd7d705be26e5ed69cf219376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa28c44fe9505f48644f06f49403fcc3"><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#aaa28c44fe9505f48644f06f49403fcc3">commitSync</a> (std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;offsets, <a class="el" href="classRdKafka_1_1OffsetCommitCb.html">OffsetCommitCb</a> *offset_commit_cb)=0</td></tr>
<tr class="memdesc:aaa28c44fe9505f48644f06f49403fcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit offsets for the provided list of partitions.  <a href="#aaa28c44fe9505f48644f06f49403fcc3">More...</a><br/></td></tr>
<tr class="separator:aaa28c44fe9505f48644f06f49403fcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4b300803fd1c9403c165b9a6431612"><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#aad4b300803fd1c9403c165b9a6431612">committed</a> (std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;partitions, int timeout_ms)=0</td></tr>
<tr class="memdesc:aad4b300803fd1c9403c165b9a6431612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve committed offsets for topics+partitions.  <a href="#aad4b300803fd1c9403c165b9a6431612">More...</a><br/></td></tr>
<tr class="separator:aad4b300803fd1c9403c165b9a6431612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49705c19baac7e00f6558fb7b4410a57"><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#a49705c19baac7e00f6558fb7b4410a57">position</a> (std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;partitions)=0</td></tr>
<tr class="memdesc:a49705c19baac7e00f6558fb7b4410a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve current positions (offsets) for topics+partitions.  <a href="#a49705c19baac7e00f6558fb7b4410a57">More...</a><br/></td></tr>
<tr class="separator:a49705c19baac7e00f6558fb7b4410a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c78a721aa91f3be9903f09ddf084644"><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#a5c78a721aa91f3be9903f09ddf084644">close</a> ()=0</td></tr>
<tr class="memdesc:a5c78a721aa91f3be9903f09ddf084644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close and shut down the proper.  <a href="#a5c78a721aa91f3be9903f09ddf084644">More...</a><br/></td></tr>
<tr class="separator:a5c78a721aa91f3be9903f09ddf084644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08a9a8175edd12ae4e1d5bb0eb50479"><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#ab08a9a8175edd12ae4e1d5bb0eb50479">seek</a> (const <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> &amp;partition, int timeout_ms)=0</td></tr>
<tr class="memdesc:ab08a9a8175edd12ae4e1d5bb0eb50479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek consumer for topic+partition to offset which is either an absolute or logical offset.  <a href="#ab08a9a8175edd12ae4e1d5bb0eb50479">More...</a><br/></td></tr>
<tr class="separator:ab08a9a8175edd12ae4e1d5bb0eb50479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab693da27c7664692d2247398d483e931"><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#ab693da27c7664692d2247398d483e931">offsets_store</a> (std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;offsets)=0</td></tr>
<tr class="memdesc:ab693da27c7664692d2247398d483e931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store offset <code>offset</code> for topic partition <code>partition</code>. The offset will be committed (written) to the offset store according to <code>auto.commit.interval.ms</code> or the next manual offset-less commit*()  <a href="#ab693da27c7664692d2247398d483e931">More...</a><br/></td></tr>
<tr class="separator:ab693da27c7664692d2247398d483e931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classRdKafka_1_1Handle"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classRdKafka_1_1Handle')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classRdKafka_1_1Handle.html">RdKafka::Handle</a></td></tr>
<tr class="memitem:abaa74be1b5b15784d47bc9c97edd0b9c inherit pub_methods_classRdKafka_1_1Handle"><td class="memItemLeft" align="right" valign="top">virtual const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1Handle.html#abaa74be1b5b15784d47bc9c97edd0b9c">name</a> () const =0</td></tr>
<tr class="separator:abaa74be1b5b15784d47bc9c97edd0b9c inherit pub_methods_classRdKafka_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0395b131921c05554688202fc0160a4 inherit pub_methods_classRdKafka_1_1Handle"><td class="memItemLeft" align="right" valign="top">virtual const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1Handle.html#ae0395b131921c05554688202fc0160a4">memberid</a> () const =0</td></tr>
<tr class="memdesc:ae0395b131921c05554688202fc0160a4 inherit pub_methods_classRdKafka_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the client's broker-assigned group member id.  <a href="#ae0395b131921c05554688202fc0160a4">More...</a><br/></td></tr>
<tr class="separator:ae0395b131921c05554688202fc0160a4 inherit pub_methods_classRdKafka_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d3b4ee48457ff13e4d5155e3fc5ea4 inherit pub_methods_classRdKafka_1_1Handle"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1Handle.html#a98d3b4ee48457ff13e4d5155e3fc5ea4">poll</a> (int timeout_ms)=0</td></tr>
<tr class="memdesc:a98d3b4ee48457ff13e4d5155e3fc5ea4 inherit pub_methods_classRdKafka_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls the provided kafka handle for events.  <a href="#a98d3b4ee48457ff13e4d5155e3fc5ea4">More...</a><br/></td></tr>
<tr class="separator:a98d3b4ee48457ff13e4d5155e3fc5ea4 inherit pub_methods_classRdKafka_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea17c83faa627056fca792be4ec6616 inherit pub_methods_classRdKafka_1_1Handle"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1Handle.html#a5ea17c83faa627056fca792be4ec6616">outq_len</a> ()=0</td></tr>
<tr class="memdesc:a5ea17c83faa627056fca792be4ec6616 inherit pub_methods_classRdKafka_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current out queue length.  <a href="#a5ea17c83faa627056fca792be4ec6616">More...</a><br/></td></tr>
<tr class="separator:a5ea17c83faa627056fca792be4ec6616 inherit pub_methods_classRdKafka_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cc63c574ce027a184640645151a75c inherit pub_methods_classRdKafka_1_1Handle"><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1Handle.html#ac0cc63c574ce027a184640645151a75c">metadata</a> (bool all_topics, const <a class="el" href="classRdKafka_1_1Topic.html">Topic</a> *only_rkt, <a class="el" href="classRdKafka_1_1Metadata.html">Metadata</a> **metadatap, int timeout_ms)=0</td></tr>
<tr class="memdesc:ac0cc63c574ce027a184640645151a75c inherit pub_methods_classRdKafka_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request <a class="el" href="classRdKafka_1_1Metadata.html" title="Metadata container. ">Metadata</a> from broker.  <a href="#ac0cc63c574ce027a184640645151a75c">More...</a><br/></td></tr>
<tr class="separator:ac0cc63c574ce027a184640645151a75c inherit pub_methods_classRdKafka_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be6579b7e2a0427b4595fb559e58d0f inherit pub_methods_classRdKafka_1_1Handle"><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1Handle.html#a6be6579b7e2a0427b4595fb559e58d0f">pause</a> (std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;partitions)=0</td></tr>
<tr class="memdesc:a6be6579b7e2a0427b4595fb559e58d0f inherit pub_methods_classRdKafka_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause producing or consumption for the provided list of partitions.  <a href="#a6be6579b7e2a0427b4595fb559e58d0f">More...</a><br/></td></tr>
<tr class="separator:a6be6579b7e2a0427b4595fb559e58d0f inherit pub_methods_classRdKafka_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322d16d6786da2b4b20505f19325fcec inherit pub_methods_classRdKafka_1_1Handle"><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1Handle.html#a322d16d6786da2b4b20505f19325fcec">resume</a> (std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;partitions)=0</td></tr>
<tr class="memdesc:a322d16d6786da2b4b20505f19325fcec inherit pub_methods_classRdKafka_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume producing or consumption for the provided list of partitions.  <a href="#a322d16d6786da2b4b20505f19325fcec">More...</a><br/></td></tr>
<tr class="separator:a322d16d6786da2b4b20505f19325fcec inherit pub_methods_classRdKafka_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74da527d73bf7b18ebeda64b3806b15 inherit pub_methods_classRdKafka_1_1Handle"><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1Handle.html#aa74da527d73bf7b18ebeda64b3806b15">query_watermark_offsets</a> (const std::string &amp;topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms)=0</td></tr>
<tr class="memdesc:aa74da527d73bf7b18ebeda64b3806b15 inherit pub_methods_classRdKafka_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query broker for low (oldest/beginning) and high (newest/end) offsets for partition.  <a href="#aa74da527d73bf7b18ebeda64b3806b15">More...</a><br/></td></tr>
<tr class="separator:aa74da527d73bf7b18ebeda64b3806b15 inherit pub_methods_classRdKafka_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37fddad61506c8749214f1f009d17ca inherit pub_methods_classRdKafka_1_1Handle"><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1Handle.html#ab37fddad61506c8749214f1f009d17ca">get_watermark_offsets</a> (const std::string &amp;topic, int32_t partition, int64_t *low, int64_t *high)=0</td></tr>
<tr class="memdesc:ab37fddad61506c8749214f1f009d17ca inherit pub_methods_classRdKafka_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get last known low (oldest/beginning) and high (newest/end) offsets for partition.  <a href="#ab37fddad61506c8749214f1f009d17ca">More...</a><br/></td></tr>
<tr class="separator:ab37fddad61506c8749214f1f009d17ca inherit pub_methods_classRdKafka_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ba69e53d3e4a9b3978ca91c205a65e inherit pub_methods_classRdKafka_1_1Handle"><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1Handle.html#a23ba69e53d3e4a9b3978ca91c205a65e">offsetsForTimes</a> (std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;offsets, int timeout_ms)=0</td></tr>
<tr class="memdesc:a23ba69e53d3e4a9b3978ca91c205a65e inherit pub_methods_classRdKafka_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the offsets for the given partitions by timestamp.  <a href="#a23ba69e53d3e4a9b3978ca91c205a65e">More...</a><br/></td></tr>
<tr class="separator:a23ba69e53d3e4a9b3978ca91c205a65e inherit pub_methods_classRdKafka_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23af70ef4129f215e5991a8065fe9efa inherit pub_methods_classRdKafka_1_1Handle"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRdKafka_1_1Queue.html">Queue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1Handle.html#a23af70ef4129f215e5991a8065fe9efa">get_partition_queue</a> (const <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> *partition)=0</td></tr>
<tr class="memdesc:a23af70ef4129f215e5991a8065fe9efa inherit pub_methods_classRdKafka_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve queue for a given partition.  <a href="#a23af70ef4129f215e5991a8065fe9efa">More...</a><br/></td></tr>
<tr class="separator:a23af70ef4129f215e5991a8065fe9efa inherit pub_methods_classRdKafka_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b3511e38e4f9f8ae1eadbdd4e11d3d inherit pub_methods_classRdKafka_1_1Handle"><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1Handle.html#ac5b3511e38e4f9f8ae1eadbdd4e11d3d">set_log_queue</a> (<a class="el" href="classRdKafka_1_1Queue.html">Queue</a> *queue)=0</td></tr>
<tr class="memdesc:ac5b3511e38e4f9f8ae1eadbdd4e11d3d inherit pub_methods_classRdKafka_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward librdkafka logs (and debug) to the specified queue for serving with one of the ..<a class="el" href="classRdKafka_1_1Handle.html#a98d3b4ee48457ff13e4d5155e3fc5ea4" title="Polls the provided kafka handle for events. ">poll()</a> calls.  <a href="#ac5b3511e38e4f9f8ae1eadbdd4e11d3d">More...</a><br/></td></tr>
<tr class="separator:ac5b3511e38e4f9f8ae1eadbdd4e11d3d inherit pub_methods_classRdKafka_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6143b8e8bbcf4bba23a687dc55ee55a3 inherit pub_methods_classRdKafka_1_1Handle"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1Handle.html#a6143b8e8bbcf4bba23a687dc55ee55a3">yield</a> ()=0</td></tr>
<tr class="memdesc:a6143b8e8bbcf4bba23a687dc55ee55a3 inherit pub_methods_classRdKafka_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels the current callback dispatcher (<a class="el" href="classRdKafka_1_1Handle.html#a98d3b4ee48457ff13e4d5155e3fc5ea4" title="Polls the provided kafka handle for events. ">Producer::poll()</a>, <a class="el" href="classRdKafka_1_1Handle.html#a98d3b4ee48457ff13e4d5155e3fc5ea4" title="Polls the provided kafka handle for events. ">Consumer::poll()</a>, <a class="el" href="classRdKafka_1_1KafkaConsumer.html#a7dc106f1c3b99767a0930a9cf8cabf84" title="Consume message or get error event, triggers callbacks. ">KafkaConsumer::consume()</a>, etc).  <a href="#a6143b8e8bbcf4bba23a687dc55ee55a3">More...</a><br/></td></tr>
<tr class="separator:a6143b8e8bbcf4bba23a687dc55ee55a3 inherit pub_methods_classRdKafka_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c275b13ff80c40c05a2284b1e8764f1 inherit pub_methods_classRdKafka_1_1Handle"><td class="memItemLeft" align="right" valign="top">virtual const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1Handle.html#a4c275b13ff80c40c05a2284b1e8764f1">clusterid</a> (int timeout_ms)=0</td></tr>
<tr class="memdesc:a4c275b13ff80c40c05a2284b1e8764f1 inherit pub_methods_classRdKafka_1_1Handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ClusterId as reported in broker metadata.  <a href="#a4c275b13ff80c40c05a2284b1e8764f1">More...</a><br/></td></tr>
<tr class="separator:a4c275b13ff80c40c05a2284b1e8764f1 inherit pub_methods_classRdKafka_1_1Handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac32a5eb3474b3315635cb1d39794d068"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRdKafka_1_1KafkaConsumer.html">KafkaConsumer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#ac32a5eb3474b3315635cb1d39794d068">create</a> (<a class="el" href="classRdKafka_1_1Conf.html">Conf</a> *conf, std::string &amp;errstr)</td></tr>
<tr class="memdesc:ac32a5eb3474b3315635cb1d39794d068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classRdKafka_1_1KafkaConsumer.html" title="High-level KafkaConsumer (for brokers 0.9 and later) ">KafkaConsumer</a>.  <a href="#ac32a5eb3474b3315635cb1d39794d068">More...</a><br/></td></tr>
<tr class="separator:ac32a5eb3474b3315635cb1d39794d068"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>High-level <a class="el" href="classRdKafka_1_1KafkaConsumer.html" title="High-level KafkaConsumer (for brokers 0.9 and later) ">KafkaConsumer</a> (for brokers 0.9 and later) </p>
<dl class="section remark"><dt>Remarks</dt><dd>Requires Apache Kafka &gt;= 0.9.0 brokers</dd></dl>
<p>Currently supports the <code>range</code> and <code>roundrobin</code> partition assignment strategies (see <code>partition.assignment.strategy</code>) </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac32a5eb3474b3315635cb1d39794d068"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRdKafka_1_1KafkaConsumer.html">KafkaConsumer</a>* RdKafka::KafkaConsumer::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRdKafka_1_1Conf.html">Conf</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>errstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classRdKafka_1_1KafkaConsumer.html" title="High-level KafkaConsumer (for brokers 0.9 and later) ">KafkaConsumer</a>. </p>
<p>The <code>conf</code> object must have <code>group.id</code> set to the consumer group to join.</p>
<p>Use <a class="el" href="classRdKafka_1_1KafkaConsumer.html#a5c78a721aa91f3be9903f09ddf084644" title="Close and shut down the proper. ">RdKafka::KafkaConsumer::close()</a> to shut down the consumer.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRdKafka_1_1RebalanceCb.html" title="KafkaConsunmer: Rebalance callback class ">RdKafka::RebalanceCb</a> </dd>
<dd>
<a class="el" href="CONFIGURATION_8md.html">CONFIGURATION.md</a> for <code>group.id</code>, <code>session.timeout.ms</code>, <code>partition.assignment.strategy</code>, etc. </dd></dl>

</div>
</div>
<a class="anchor" id="a7404297cecc9be656026c6c6154ce2bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::subscribe </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>topics</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the subscription set to <code>topics</code>. </p>
<p>Any previous subscription will be unassigned and unsubscribed first.</p>
<p>The subscription set denotes the desired topics to consume and this set is provided to the partition assignor (one of the elected group members) for all clients which then uses the configured <code>partition.assignment.strategy</code> to assign the subscription sets's topics's partitions to the consumers, depending on their subscription.</p>
<p>The result of such an assignment is a rebalancing which is either handled automatically in librdkafka or can be overriden by the application by providing a <a class="el" href="classRdKafka_1_1RebalanceCb.html" title="KafkaConsunmer: Rebalance callback class ">RdKafka::RebalanceCb</a>.</p>
<p>The rebalancing passes the assigned partition set to <a class="el" href="classRdKafka_1_1KafkaConsumer.html#af3f872bcb7d46febbaea63518f854b46" title="Update the assignment set to partitions. ">RdKafka::KafkaConsumer::assign()</a> to update what partitions are actually being fetched by the <a class="el" href="classRdKafka_1_1KafkaConsumer.html" title="High-level KafkaConsumer (for brokers 0.9 and later) ">KafkaConsumer</a>.</p>
<p>Regex pattern matching automatically performed for topics prefixed with <code>"^"</code> (e.g. <code>"^myPfx</code>[0-9]_.*"</p>
<dl class="section return"><dt>Returns</dt><dd>an error if the provided list of topics is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="af3f872bcb7d46febbaea63518f854b46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::assign </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>partitions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the assignment set to <code>partitions</code>. </p>
<p>The assignment set is the set of partitions actually being consumed by the <a class="el" href="classRdKafka_1_1KafkaConsumer.html" title="High-level KafkaConsumer (for brokers 0.9 and later) ">KafkaConsumer</a>. </p>

</div>
</div>
<a class="anchor" id="a7dc106f1c3b99767a0930a9cf8cabf84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRdKafka_1_1Message.html">Message</a>* RdKafka::KafkaConsumer::consume </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consume message or get error event, triggers callbacks. </p>
<p>Will automatically call registered callbacks for any such queued events, including <a class="el" href="classRdKafka_1_1RebalanceCb.html" title="KafkaConsunmer: Rebalance callback class ">RdKafka::RebalanceCb</a>, <a class="el" href="classRdKafka_1_1EventCb.html" title="Event callback class. ">RdKafka::EventCb</a>, <a class="el" href="classRdKafka_1_1OffsetCommitCb.html" title="Offset Commit callback class. ">RdKafka::OffsetCommitCb</a>, etc.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Use <code>delete</code> to free the message.</dd>
<dd>
An application should make sure to call <a class="el" href="classRdKafka_1_1KafkaConsumer.html#a7dc106f1c3b99767a0930a9cf8cabf84" title="Consume message or get error event, triggers callbacks. ">consume()</a> at regular intervals, even if no messages are expected, to serve any queued callbacks waiting to be called. This is especially important when a <a class="el" href="classRdKafka_1_1RebalanceCb.html" title="KafkaConsunmer: Rebalance callback class ">RebalanceCb</a> has been registered as it needs to be called and handled properly to synchronize internal consumer state.</dd>
<dd>
Application MUST NOT call <code><a class="el" href="classRdKafka_1_1Handle.html#a98d3b4ee48457ff13e4d5155e3fc5ea4" title="Polls the provided kafka handle for events. ">poll()</a></code> on <a class="el" href="classRdKafka_1_1KafkaConsumer.html" title="High-level KafkaConsumer (for brokers 0.9 and later) ">KafkaConsumer</a> objects.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>One of:<ul>
<li>proper message (<a class="el" href="classRdKafka_1_1Message.html#a90df1fd2a73a74220c9581e6bedb42f2">RdKafka::Message::err()</a> is ERR_NO_ERROR)</li>
<li>error event (<a class="el" href="classRdKafka_1_1Message.html#a90df1fd2a73a74220c9581e6bedb42f2">RdKafka::Message::err()</a> is != ERR_NO_ERROR)</li>
<li>timeout due to no message or event in <code>timeout_ms</code> (<a class="el" href="classRdKafka_1_1Message.html#a90df1fd2a73a74220c9581e6bedb42f2">RdKafka::Message::err()</a> is ERR__TIMED_OUT) </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1c421bf2b44509704ad3d9e785c5b15c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::commitSync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Commit offsets for the current assignment. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is the synchronous variant that blocks until offsets are committed or the commit fails (see return value).</dd>
<dd>
If a <a class="el" href="classRdKafka_1_1OffsetCommitCb.html" title="Offset Commit callback class. ">RdKafka::OffsetCommitCb</a> callback is registered it will be called with commit details on a future call to <a class="el" href="classRdKafka_1_1KafkaConsumer.html#a7dc106f1c3b99767a0930a9cf8cabf84" title="Consume message or get error event, triggers callbacks. ">RdKafka::KafkaConsumer::consume()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_NO_ERROR or error code. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d68b1b8d21dc26499938cb6e529f928"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::commitAsync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronous version of RdKafka::KafkaConsumer::CommitSync() </p>
<dl class="section see"><dt>See Also</dt><dd>RdKafka::KafkaConsummer::commitSync() </dd></dl>

</div>
</div>
<a class="anchor" id="ac5d1b4fcadea749b774ab1cdd62de2d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::commitSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRdKafka_1_1Message.html">Message</a> *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Commit offset for a single topic+partition based on <code>message</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is the synchronous variant.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>RdKafka::KafkaConsummer::commitSync() </dd></dl>

</div>
</div>
<a class="anchor" id="a278db6d20ebcaf501af9487c0957d57f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::commitAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRdKafka_1_1Message.html">Message</a> *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Commit offset for a single topic+partition based on <code>message</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is the asynchronous variant.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>RdKafka::KafkaConsummer::commitSync() </dd></dl>

</div>
</div>
<a class="anchor" id="a892f5ec51f898b67a19d892b9ab08177"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::commitSync </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Commit offsets for the provided list of partitions. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is the synchronous variant. </dd></dl>

</div>
</div>
<a class="anchor" id="a66a2c7639521e0c9eb25c3417921e318"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::commitAsync </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Commit offset for the provided list of partitions. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is the asynchronous variant. </dd></dl>

</div>
</div>
<a class="anchor" id="a6791befdd7d705be26e5ed69cf219376"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::commitSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRdKafka_1_1OffsetCommitCb.html">OffsetCommitCb</a> *&#160;</td>
          <td class="paramname"><em>offset_commit_cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Commit offsets for the current assignment. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is the synchronous variant that blocks until offsets are committed or the commit fails (see return value).</dd>
<dd>
The provided callback will be called from this function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_NO_ERROR or error code. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa28c44fe9505f48644f06f49403fcc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::commitSync </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRdKafka_1_1OffsetCommitCb.html">OffsetCommitCb</a> *&#160;</td>
          <td class="paramname"><em>offset_commit_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Commit offsets for the provided list of partitions. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is the synchronous variant that blocks until offsets are committed or the commit fails (see return value).</dd>
<dd>
The provided callback will be called from this function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_NO_ERROR or error code. </dd></dl>

</div>
</div>
<a class="anchor" id="aad4b300803fd1c9403c165b9a6431612"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::committed </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve committed offsets for topics+partitions. </p>
<dl class="section return"><dt>Returns</dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success in which case the <code>offset</code> or <code>err</code> field of each <code>partitions'</code> element is filled in with the stored offset, or a partition specific error. Else returns an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="a49705c19baac7e00f6558fb7b4410a57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::position </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>partitions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve current positions (offsets) for topics+partitions. </p>
<dl class="section return"><dt>Returns</dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success in which case the <code>offset</code> or <code>err</code> field of each <code>partitions'</code> element is filled in with the stored offset, or a partition specific error. Else returns an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c78a721aa91f3be9903f09ddf084644"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close and shut down the proper. </p>
<p>For pausing and resuming consumption, see </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRdKafka_1_1Handle.html#a6be6579b7e2a0427b4595fb559e58d0f" title="Pause producing or consumption for the provided list of partitions. ">RdKafka::Handle::pause()</a> and <a class="el" href="classRdKafka_1_1Handle.html#a322d16d6786da2b4b20505f19325fcec" title="Resume producing or consumption for the provided list of partitions. ">RdKafka::Handle::resume()</a> This call will block until the following operations are finished:<ul>
<li>Trigger a local rebalance to void the current <a class="el" href="classRdKafka_1_1KafkaConsumer.html#afd22626a2b370f378272e30411df6f78" title="Returns the current partition assignment as set by RdKafka::KafkaConsumer::assign() ...">assignment</a></li>
<li>Stop consumption for current <a class="el" href="classRdKafka_1_1KafkaConsumer.html#afd22626a2b370f378272e30411df6f78" title="Returns the current partition assignment as set by RdKafka::KafkaConsumer::assign() ...">assignment</a></li>
<li>Commit offsets</li>
<li>Leave group</li>
</ul>
</dd></dl>
<p>The maximum blocking time is roughly limited to session.timeout.ms.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Callbacks, such as <a class="el" href="classRdKafka_1_1RebalanceCb.html" title="KafkaConsunmer: Rebalance callback class ">RdKafka::RebalanceCb</a> and <a class="el" href="classRdKafka_1_1OffsetCommitCb.html" title="Offset Commit callback class. ">RdKafka::OffsetCommitCb</a>, etc, may be called.</dd>
<dd>
The consumer object must later be freed with <code>delete</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ab08a9a8175edd12ae4e1d5bb0eb50479"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::seek </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> &amp;&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Seek consumer for topic+partition to offset which is either an absolute or logical offset. </p>
<p>If <code>timeout_ms</code> is not 0 the call will wait this long for the seek to be performed. If the timeout is reached the internal state will be unknown and this function returns <code>ERR__TIMED_OUT</code>. If <code>timeout_ms</code> is 0 it will initiate the seek but return immediately without any error reporting (e.g., async).</p>
<p>This call triggers a fetch queue barrier flush.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Consumtion for the given partition must have started for the seek to work. Use <a class="el" href="classRdKafka_1_1KafkaConsumer.html#af3f872bcb7d46febbaea63518f854b46" title="Update the assignment set to partitions. ">assign()</a> to set the starting offset.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an ErrorCode to indicate success or failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ab693da27c7664692d2247398d483e931"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::offsets_store </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store offset <code>offset</code> for topic partition <code>partition</code>. The offset will be committed (written) to the offset store according to <code>auto.commit.interval.ms</code> or the next manual offset-less commit*() </p>
<p>Per-partition success/error status propagated through <a class="el" href="classRdKafka_1_1TopicPartition.html#adf4cd4ca1ed51f1829fddd475b96adee">TopicPartition.err()</a></p>
<dl class="section remark"><dt>Remarks</dt><dd><code>enable.auto.offset.store</code> must be set to <code>false</code> when using this API.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>RdKafka::ERR_NO_ERROR on success or an error code on error. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src-cpp/<a class="el" href="rdkafkacpp_8h_source.html">rdkafkacpp.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>RdKafka</b></li><li class="navelem"><a class="el" href="classRdKafka_1_1KafkaConsumer.html">KafkaConsumer</a></li>
    <li class="footer">Generated on Thu Aug 3 2017 14:04:47 for librdkafka by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
