<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>librdkafka: src/rdkafka.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">librdkafka
   </div>
   <div id="projectbrief">The Apache Kafka C/C++ client library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('rdkafka_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">rdkafka.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Apache Kafka C/C++ consumer and producer client library.  
<a href="#details">More...</a></p>

<p><a href="rdkafka_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__err__desc.html">rd_kafka_err_desc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error code value, name and description. Typically for use with language bindings to automatically expose the full set of librdkafka error codes.  <a href="structrd__kafka__err__desc.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__topic__partition__t.html">rd_kafka_topic_partition_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topic+Partition place holder.  <a href="structrd__kafka__topic__partition__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A growable list of Topic+Partitions.  <a href="structrd__kafka__topic__partition__list__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Kafka message as returned by the <code>rd_kafka_consume*</code>() family of functions as well as provided to the Producer <code>dr_msg_cb()</code>.  <a href="structrd__kafka__message__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__metadata__broker__t.html">rd_kafka_metadata_broker_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broker information.  <a href="structrd__kafka__metadata__broker__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__metadata__partition__t.html">rd_kafka_metadata_partition_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition information.  <a href="structrd__kafka__metadata__partition__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__metadata__topic__t.html">rd_kafka_metadata_topic_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topic information.  <a href="structrd__kafka__metadata__topic__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__metadata__t.html">rd_kafka_metadata_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metadata container.  <a href="structrd__kafka__metadata__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__group__member__info.html">rd_kafka_group_member_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group member information.  <a href="structrd__kafka__group__member__info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__group__info.html">rd_kafka_group_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group information.  <a href="structrd__kafka__group__info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__group__list.html">rd_kafka_group_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of groups.  <a href="structrd__kafka__group__list.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Plugin interface</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>A plugin interface that allows external runtime-loaded libraries to integrate with a client instance without modifications to the application code.</p>
<pre class="fragment">   Plugins are loaded when referenced through the `plugin.library.paths`
   configuration property and operates on the \c rd_kafka_conf_t
   object prior \c rd_kafka_t instance creation.
</pre><dl class="section warning"><dt>Warning</dt><dd>Plugins require the application to link librdkafka dynamically and not statically. Failure to do so will lead to missing symbols or finding symbols in another librdkafka library than the application was linked with. </dd></dl>
</div></td></tr>
<tr class="memitem:a15f8730945790c3c5fb366f2970f73b8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a15f8730945790c3c5fb366f2970f73b8">rd_kafka_plugin_f_conf_init_t</a> )(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size)</td></tr>
<tr class="memdesc:a15f8730945790c3c5fb366f2970f73b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plugin's configuration initializer method called each time the library is referenced from configuration (even if previously loaded by another client instance).  <a href="#a15f8730945790c3c5fb366f2970f73b8">More...</a><br/></td></tr>
<tr class="separator:a15f8730945790c3c5fb366f2970f73b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Kafka messages</div></td></tr>
<tr class="memitem:a35e0c519209d1afe9e29468f766c1c24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35e0c519209d1afe9e29468f766c1c24"></a>
RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a35e0c519209d1afe9e29468f766c1c24">rd_kafka_message_destroy</a> (<a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage)</td></tr>
<tr class="memdesc:a35e0c519209d1afe9e29468f766c1c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees resources for <code>rkmessage</code> and hands ownership back to rdkafka. <br/></td></tr>
<tr class="separator:a35e0c519209d1afe9e29468f766c1c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929ad59ee41ceb4e2f36c8212a5a54ec"><td class="memItemLeft" align="right" valign="top">static RD_INLINE const char <br class="typebreak"/>
*RD_UNUSED&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a929ad59ee41ceb4e2f36c8212a5a54ec">rd_kafka_message_errstr</a> (const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage)</td></tr>
<tr class="memdesc:a929ad59ee41ceb4e2f36c8212a5a54ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error string for an errored <a class="el" href="structrd__kafka__message__t.html" title="A Kafka message as returned by the rd_kafka_consume*() family of functions as well as provided to the...">rd_kafka_message_t</a> or NULL if there was no error.  <a href="#a929ad59ee41ceb4e2f36c8212a5a54ec">More...</a><br/></td></tr>
<tr class="separator:a929ad59ee41ceb4e2f36c8212a5a54ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4371deba4afe6941cc5f9e80df5ca3e7"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a4371deba4afe6941cc5f9e80df5ca3e7">rd_kafka_message_timestamp</a> (const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, <a class="el" href="rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3">rd_kafka_timestamp_type_t</a> *tstype)</td></tr>
<tr class="memdesc:a4371deba4afe6941cc5f9e80df5ca3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the message timestamp for a consumed message.  <a href="#a4371deba4afe6941cc5f9e80df5ca3e7">More...</a><br/></td></tr>
<tr class="separator:a4371deba4afe6941cc5f9e80df5ca3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba20435b42efef7a3c38dee3fb58c27b"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aba20435b42efef7a3c38dee3fb58c27b">rd_kafka_message_latency</a> (const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage)</td></tr>
<tr class="memdesc:aba20435b42efef7a3c38dee3fb58c27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the latency for a produced message measured from the produce() call.  <a href="#aba20435b42efef7a3c38dee3fb58c27b">More...</a><br/></td></tr>
<tr class="separator:aba20435b42efef7a3c38dee3fb58c27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Topic configuration</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Topic configuration property interface </p>
</div></td></tr>
<tr class="memitem:a1a7032f87e7d868b80e38d0fd0ad119e"><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_topic_conf_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a1a7032f87e7d868b80e38d0fd0ad119e">rd_kafka_topic_conf_new</a> (void)</td></tr>
<tr class="memdesc:a1a7032f87e7d868b80e38d0fd0ad119e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create topic configuration object.  <a href="#a1a7032f87e7d868b80e38d0fd0ad119e">More...</a><br/></td></tr>
<tr class="separator:a1a7032f87e7d868b80e38d0fd0ad119e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15de16feecd5fd5ce60e90126d83a062"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15de16feecd5fd5ce60e90126d83a062"></a>
RD_EXPORT rd_kafka_topic_conf_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a15de16feecd5fd5ce60e90126d83a062">rd_kafka_topic_conf_dup</a> (const rd_kafka_topic_conf_t *conf)</td></tr>
<tr class="memdesc:a15de16feecd5fd5ce60e90126d83a062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy/duplicate of topic configuration object <code>conf</code>. <br/></td></tr>
<tr class="separator:a15de16feecd5fd5ce60e90126d83a062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f83e53bd89531f662644f549c85d9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3f83e53bd89531f662644f549c85d9f"></a>
RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ac3f83e53bd89531f662644f549c85d9f">rd_kafka_topic_conf_destroy</a> (rd_kafka_topic_conf_t *topic_conf)</td></tr>
<tr class="memdesc:ac3f83e53bd89531f662644f549c85d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a topic conf object. <br/></td></tr>
<tr class="separator:ac3f83e53bd89531f662644f549c85d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91b47f7733b324bf4159427e90ccd01"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ac91b47f7733b324bf4159427e90ccd01">rd_kafka_topic_conf_set</a> (rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size)</td></tr>
<tr class="memdesc:ac91b47f7733b324bf4159427e90ccd01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a single rd_kafka_topic_conf_t value by property name.  <a href="#ac91b47f7733b324bf4159427e90ccd01">More...</a><br/></td></tr>
<tr class="separator:ac91b47f7733b324bf4159427e90ccd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade099479af64ad87af7c5c6c953f18e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade099479af64ad87af7c5c6c953f18e0"></a>
RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ade099479af64ad87af7c5c6c953f18e0">rd_kafka_topic_conf_set_opaque</a> (rd_kafka_topic_conf_t *conf, void *opaque)</td></tr>
<tr class="memdesc:ade099479af64ad87af7c5c6c953f18e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the application's opaque pointer that will be passed to all topic callbacks as the <code>rkt_opaque</code> argument. <br/></td></tr>
<tr class="separator:ade099479af64ad87af7c5c6c953f18e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc790b5e36c56ea6d79fdc32c57becf"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#abfc790b5e36c56ea6d79fdc32c57becf">rd_kafka_topic_conf_set_partitioner_cb</a> (rd_kafka_topic_conf_t *topic_conf, int32_t(*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque))</td></tr>
<tr class="memdesc:abfc790b5e36c56ea6d79fdc32c57becf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Producer:</b> Set partitioner callback in provided topic conf object.  <a href="#abfc790b5e36c56ea6d79fdc32c57becf">More...</a><br/></td></tr>
<tr class="separator:abfc790b5e36c56ea6d79fdc32c57becf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24c6cc7f37271e292f8105c64d77758"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ad24c6cc7f37271e292f8105c64d77758">rd_kafka_topic_partition_available</a> (const rd_kafka_topic_t *rkt, int32_t partition)</td></tr>
<tr class="memdesc:ad24c6cc7f37271e292f8105c64d77758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if partition is available (has a leader broker).  <a href="#ad24c6cc7f37271e292f8105c64d77758">More...</a><br/></td></tr>
<tr class="separator:ad24c6cc7f37271e292f8105c64d77758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8690da243d6d22f52cf8a6f0e90d7e8"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ae8690da243d6d22f52cf8a6f0e90d7e8">rd_kafka_msg_partitioner_random</a> (const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque)</td></tr>
<tr class="memdesc:ae8690da243d6d22f52cf8a6f0e90d7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random partitioner.  <a href="#ae8690da243d6d22f52cf8a6f0e90d7e8">More...</a><br/></td></tr>
<tr class="separator:ae8690da243d6d22f52cf8a6f0e90d7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09edd9204e8fb28dae7a8b000d4492ef"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a09edd9204e8fb28dae7a8b000d4492ef">rd_kafka_msg_partitioner_consistent</a> (const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque)</td></tr>
<tr class="memdesc:a09edd9204e8fb28dae7a8b000d4492ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consistent partitioner.  <a href="#a09edd9204e8fb28dae7a8b000d4492ef">More...</a><br/></td></tr>
<tr class="separator:a09edd9204e8fb28dae7a8b000d4492ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b79580e110b06ea5434fb71abc0b4eb"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a2b79580e110b06ea5434fb71abc0b4eb">rd_kafka_msg_partitioner_consistent_random</a> (const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque)</td></tr>
<tr class="memdesc:a2b79580e110b06ea5434fb71abc0b4eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consistent-Random partitioner.  <a href="#a2b79580e110b06ea5434fb71abc0b4eb">More...</a><br/></td></tr>
<tr class="separator:a2b79580e110b06ea5434fb71abc0b4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Queue API</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Message queues allows the application to re-route consumed messages from multiple topic+partitions into one single queue point. This queue point containing messages from a number of topic+partitions may then be served by a single rd_kafka_consume*_queue() call, rather than one call per topic+partition combination. </p>
</div></td></tr>
<tr class="memitem:a2b59178eb7e88d40510a89f3f2d98b44"><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_queue_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a2b59178eb7e88d40510a89f3f2d98b44">rd_kafka_queue_new</a> (rd_kafka_t *rk)</td></tr>
<tr class="memdesc:a2b59178eb7e88d40510a89f3f2d98b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new message queue.  <a href="#a2b59178eb7e88d40510a89f3f2d98b44">More...</a><br/></td></tr>
<tr class="separator:a2b59178eb7e88d40510a89f3f2d98b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9421b3d450f1489cf46f68d49c5ea61e"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a9421b3d450f1489cf46f68d49c5ea61e">rd_kafka_queue_destroy</a> (rd_kafka_queue_t *rkqu)</td></tr>
<tr class="separator:a9421b3d450f1489cf46f68d49c5ea61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3d675ee029a52bf85fb28f83c38863"><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_queue_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a7f3d675ee029a52bf85fb28f83c38863">rd_kafka_queue_get_main</a> (rd_kafka_t *rk)</td></tr>
<tr class="separator:a7f3d675ee029a52bf85fb28f83c38863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacdb55ae7cb6abfbde89621e512b078"><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_queue_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#acacdb55ae7cb6abfbde89621e512b078">rd_kafka_queue_get_consumer</a> (rd_kafka_t *rk)</td></tr>
<tr class="separator:acacdb55ae7cb6abfbde89621e512b078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5319a26efb9f843c6029f7dd54b742d"><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_queue_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ad5319a26efb9f843c6029f7dd54b742d">rd_kafka_queue_get_partition</a> (rd_kafka_t *rk, const char *topic, int32_t partition)</td></tr>
<tr class="separator:ad5319a26efb9f843c6029f7dd54b742d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2e5571d14636d289f963a270b8e338"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a5e2e5571d14636d289f963a270b8e338">rd_kafka_queue_forward</a> (rd_kafka_queue_t *src, rd_kafka_queue_t *dst)</td></tr>
<tr class="memdesc:a5e2e5571d14636d289f963a270b8e338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward/re-route queue <code>src</code> to <code>dst</code>. If <code>dst</code> is <code>NULL</code> the forwarding is removed.  <a href="#a5e2e5571d14636d289f963a270b8e338">More...</a><br/></td></tr>
<tr class="separator:a5e2e5571d14636d289f963a270b8e338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8a3be2f797560b2a39bf56dbd7622d"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a5c8a3be2f797560b2a39bf56dbd7622d">rd_kafka_set_log_queue</a> (rd_kafka_t *rk, rd_kafka_queue_t *rkqu)</td></tr>
<tr class="memdesc:a5c8a3be2f797560b2a39bf56dbd7622d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward librdkafka logs (and debug) to the specified queue for serving with one of the ..poll() calls.  <a href="#a5c8a3be2f797560b2a39bf56dbd7622d">More...</a><br/></td></tr>
<tr class="separator:a5c8a3be2f797560b2a39bf56dbd7622d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f24368f4ff0e042907773f532f62e57"><td class="memItemLeft" align="right" valign="top">RD_EXPORT size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a8f24368f4ff0e042907773f532f62e57">rd_kafka_queue_length</a> (rd_kafka_queue_t *rkqu)</td></tr>
<tr class="separator:a8f24368f4ff0e042907773f532f62e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbdd13ab480f6320b2842981eebce784"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#acbdd13ab480f6320b2842981eebce784">rd_kafka_queue_io_event_enable</a> (rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size)</td></tr>
<tr class="memdesc:acbdd13ab480f6320b2842981eebce784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable IO event triggering for queue.  <a href="#acbdd13ab480f6320b2842981eebce784">More...</a><br/></td></tr>
<tr class="separator:acbdd13ab480f6320b2842981eebce784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Simple Consumer API (legacy): Queue consumers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The following <code>..._queue()</code> functions are analogue to the functions above but reads messages from the provided queue <code>rkqu</code> instead. <code>rkqu</code> must have been previously created with <code><a class="el" href="rdkafka_8h.html#a2b59178eb7e88d40510a89f3f2d98b44" title="Create a new message queue. ">rd_kafka_queue_new()</a></code> and the topic consumer must have been started with <code><a class="el" href="rdkafka_8h.html#a8e952d7961169471f69c7ddc87041258" title="Same as rd_kafka_consume_start() but re-routes incoming messages to the provided queue rkqu (which mu...">rd_kafka_consume_start_queue()</a></code> utilising the the same queue. </p>
</div></td></tr>
<tr class="memitem:a8ff0b80fccb3a5bd31b1baaf20e4ca16"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a8ff0b80fccb3a5bd31b1baaf20e4ca16">rd_kafka_consume_queue</a> (rd_kafka_queue_t *rkqu, int timeout_ms)</td></tr>
<tr class="memdesc:a8ff0b80fccb3a5bd31b1baaf20e4ca16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consume from queue.  <a href="#a8ff0b80fccb3a5bd31b1baaf20e4ca16">More...</a><br/></td></tr>
<tr class="separator:a8ff0b80fccb3a5bd31b1baaf20e4ca16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d949238471993b18537855aad28fa23"><td class="memItemLeft" align="right" valign="top">RD_EXPORT ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a3d949238471993b18537855aad28fa23">rd_kafka_consume_batch_queue</a> (rd_kafka_queue_t *rkqu, int timeout_ms, <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> **rkmessages, size_t rkmessages_size)</td></tr>
<tr class="memdesc:a3d949238471993b18537855aad28fa23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consume batch of messages from queue.  <a href="#a3d949238471993b18537855aad28fa23">More...</a><br/></td></tr>
<tr class="separator:a3d949238471993b18537855aad28fa23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1aaca2499c2e7d6da37dc28953d532"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#abb1aaca2499c2e7d6da37dc28953d532">rd_kafka_consume_callback_queue</a> (rd_kafka_queue_t *rkqu, int timeout_ms, void(*consume_cb)(<a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *opaque), void *opaque)</td></tr>
<tr class="memdesc:abb1aaca2499c2e7d6da37dc28953d532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consume multiple messages from queue with callback.  <a href="#abb1aaca2499c2e7d6da37dc28953d532">More...</a><br/></td></tr>
<tr class="separator:abb1aaca2499c2e7d6da37dc28953d532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Simple Consumer API (legacy): Topic+partition offset store.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>If <code>auto.commit.enable</code> is true the offset is stored automatically prior to returning of the message(s) in each of the rd_kafka_consume*() functions above. </p>
</div></td></tr>
<tr class="memitem:a784186db1d2cb6ceebcd5606d38db4c4"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a784186db1d2cb6ceebcd5606d38db4c4">rd_kafka_offset_store</a> (rd_kafka_topic_t *rkt, int32_t partition, int64_t offset)</td></tr>
<tr class="memdesc:a784186db1d2cb6ceebcd5606d38db4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store offset <code>offset</code> for topic <code>rkt</code> partition <code>partition</code>.  <a href="#a784186db1d2cb6ceebcd5606d38db4c4">More...</a><br/></td></tr>
<tr class="separator:a784186db1d2cb6ceebcd5606d38db4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047b1e21236fba30898c7c563c2c6777"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a047b1e21236fba30898c7c563c2c6777">rd_kafka_offsets_store</a> (rd_kafka_t *rk, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *offsets)</td></tr>
<tr class="memdesc:a047b1e21236fba30898c7c563c2c6777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store offsets for one or more partitions.  <a href="#a047b1e21236fba30898c7c563c2c6777">More...</a><br/></td></tr>
<tr class="separator:a047b1e21236fba30898c7c563c2c6777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">KafkaConsumer (C)</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>High-level KafkaConsumer C API </p>
</div></td></tr>
<tr class="memitem:a0ebe15e9d0f39ccc84e9686f0fcf46f1"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0ebe15e9d0f39ccc84e9686f0fcf46f1">rd_kafka_subscribe</a> (rd_kafka_t *rk, const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *topics)</td></tr>
<tr class="memdesc:a0ebe15e9d0f39ccc84e9686f0fcf46f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe to topic set using balanced consumer groups.  <a href="#a0ebe15e9d0f39ccc84e9686f0fcf46f1">More...</a><br/></td></tr>
<tr class="separator:a0ebe15e9d0f39ccc84e9686f0fcf46f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca43b89dd1696f1d22e4e4ad49345b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ca43b89dd1696f1d22e4e4ad49345b9"></a>
RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a3ca43b89dd1696f1d22e4e4ad49345b9">rd_kafka_unsubscribe</a> (rd_kafka_t *rk)</td></tr>
<tr class="memdesc:a3ca43b89dd1696f1d22e4e4ad49345b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe from the current subscription set. <br/></td></tr>
<tr class="separator:a3ca43b89dd1696f1d22e4e4ad49345b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66a2c014db2e652aa12466b137a6200"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab66a2c014db2e652aa12466b137a6200">rd_kafka_subscription</a> (rd_kafka_t *rk, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> **topics)</td></tr>
<tr class="memdesc:ab66a2c014db2e652aa12466b137a6200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current topic subscription.  <a href="#ab66a2c014db2e652aa12466b137a6200">More...</a><br/></td></tr>
<tr class="separator:ab66a2c014db2e652aa12466b137a6200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cc6cb9bd72c4084f074af0361ceddf"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf">rd_kafka_consumer_poll</a> (rd_kafka_t *rk, int timeout_ms)</td></tr>
<tr class="memdesc:a65cc6cb9bd72c4084f074af0361ceddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll the consumer for messages or events.  <a href="#a65cc6cb9bd72c4084f074af0361ceddf">More...</a><br/></td></tr>
<tr class="separator:a65cc6cb9bd72c4084f074af0361ceddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b54d329e12d745889defe96e7d043d"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a37b54d329e12d745889defe96e7d043d">rd_kafka_consumer_close</a> (rd_kafka_t *rk)</td></tr>
<tr class="memdesc:a37b54d329e12d745889defe96e7d043d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close down the KafkaConsumer.  <a href="#a37b54d329e12d745889defe96e7d043d">More...</a><br/></td></tr>
<tr class="separator:a37b54d329e12d745889defe96e7d043d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0566419eff2001f8371e3b50aa7d26e9"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0566419eff2001f8371e3b50aa7d26e9">rd_kafka_assign</a> (rd_kafka_t *rk, const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *partitions)</td></tr>
<tr class="memdesc:a0566419eff2001f8371e3b50aa7d26e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic assignment of partitions to consume.  <a href="#a0566419eff2001f8371e3b50aa7d26e9">More...</a><br/></td></tr>
<tr class="separator:a0566419eff2001f8371e3b50aa7d26e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a00cc624a46209fe1192cfc56cce59"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a10a00cc624a46209fe1192cfc56cce59">rd_kafka_assignment</a> (rd_kafka_t *rk, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> **partitions)</td></tr>
<tr class="memdesc:a10a00cc624a46209fe1192cfc56cce59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current partition assignment.  <a href="#a10a00cc624a46209fe1192cfc56cce59">More...</a><br/></td></tr>
<tr class="separator:a10a00cc624a46209fe1192cfc56cce59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96539928328f14c3c9177ea0c896c87"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab96539928328f14c3c9177ea0c896c87">rd_kafka_commit</a> (rd_kafka_t *rk, const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *offsets, int async)</td></tr>
<tr class="memdesc:ab96539928328f14c3c9177ea0c896c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit offsets on broker for the provided list of partitions.  <a href="#ab96539928328f14c3c9177ea0c896c87">More...</a><br/></td></tr>
<tr class="separator:ab96539928328f14c3c9177ea0c896c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fb25d50216e4e20d303bf8a4a62883"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a99fb25d50216e4e20d303bf8a4a62883">rd_kafka_commit_message</a> (rd_kafka_t *rk, const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, int async)</td></tr>
<tr class="memdesc:a99fb25d50216e4e20d303bf8a4a62883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit message's offset on broker for the message's partition.  <a href="#a99fb25d50216e4e20d303bf8a4a62883">More...</a><br/></td></tr>
<tr class="separator:a99fb25d50216e4e20d303bf8a4a62883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa793dd9c195f39bcb69465cebf534c47"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aa793dd9c195f39bcb69465cebf534c47">rd_kafka_commit_queue</a> (rd_kafka_t *rk, const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *offsets, rd_kafka_queue_t *rkqu, void(*cb)(rd_kafka_t *rk, <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *offsets, void *opaque), void *opaque)</td></tr>
<tr class="memdesc:aa793dd9c195f39bcb69465cebf534c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit offsets on broker for the provided list of partitions.  <a href="#aa793dd9c195f39bcb69465cebf534c47">More...</a><br/></td></tr>
<tr class="separator:aa793dd9c195f39bcb69465cebf534c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39846ae321a03c4679c9c659f18adf13"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a39846ae321a03c4679c9c659f18adf13">rd_kafka_committed</a> (rd_kafka_t *rk, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *partitions, int timeout_ms)</td></tr>
<tr class="memdesc:a39846ae321a03c4679c9c659f18adf13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve committed offsets for topics+partitions.  <a href="#a39846ae321a03c4679c9c659f18adf13">More...</a><br/></td></tr>
<tr class="separator:a39846ae321a03c4679c9c659f18adf13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9e36bd9e6bf84a9f3092fcbfa3a9ac"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a6e9e36bd9e6bf84a9f3092fcbfa3a9ac">rd_kafka_position</a> (rd_kafka_t *rk, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *partitions)</td></tr>
<tr class="memdesc:a6e9e36bd9e6bf84a9f3092fcbfa3a9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve current positions (offsets) for topics+partitions.  <a href="#a6e9e36bd9e6bf84a9f3092fcbfa3a9ac">More...</a><br/></td></tr>
<tr class="separator:a6e9e36bd9e6bf84a9f3092fcbfa3a9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Metadata API</div></td></tr>
<tr class="memitem:a84bba4a4b13fdb515f1a22d6fd4f7344"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a84bba4a4b13fdb515f1a22d6fd4f7344">rd_kafka_metadata</a> (rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms)</td></tr>
<tr class="memdesc:a84bba4a4b13fdb515f1a22d6fd4f7344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request Metadata from broker.  <a href="#a84bba4a4b13fdb515f1a22d6fd4f7344">More...</a><br/></td></tr>
<tr class="separator:a84bba4a4b13fdb515f1a22d6fd4f7344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4ee98ab1c76f3504edf9eed986844e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b4ee98ab1c76f3504edf9eed986844e"></a>
RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0b4ee98ab1c76f3504edf9eed986844e">rd_kafka_metadata_destroy</a> (const struct <a class="el" href="rdkafka_8h.html#a84bba4a4b13fdb515f1a22d6fd4f7344">rd_kafka_metadata</a> *metadata)</td></tr>
<tr class="memdesc:a0b4ee98ab1c76f3504edf9eed986844e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release metadata memory. <br/></td></tr>
<tr class="separator:a0b4ee98ab1c76f3504edf9eed986844e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Client group information</div></td></tr>
<tr class="memitem:a6cfc79819453ecd4aa94fbae6dbbea0a"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a6cfc79819453ecd4aa94fbae6dbbea0a">rd_kafka_list_groups</a> (rd_kafka_t *rk, const char *group, const struct <a class="el" href="structrd__kafka__group__list.html">rd_kafka_group_list</a> **grplistp, int timeout_ms)</td></tr>
<tr class="memdesc:a6cfc79819453ecd4aa94fbae6dbbea0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">List and describe client groups in cluster.  <a href="#a6cfc79819453ecd4aa94fbae6dbbea0a">More...</a><br/></td></tr>
<tr class="separator:a6cfc79819453ecd4aa94fbae6dbbea0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28e1cb749e7e62168107ccdee1960ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab28e1cb749e7e62168107ccdee1960ea"></a>
RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab28e1cb749e7e62168107ccdee1960ea">rd_kafka_group_list_destroy</a> (const struct <a class="el" href="structrd__kafka__group__list.html">rd_kafka_group_list</a> *grplist)</td></tr>
<tr class="memdesc:ab28e1cb749e7e62168107ccdee1960ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release list memory. <br/></td></tr>
<tr class="separator:ab28e1cb749e7e62168107ccdee1960ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous APIs</div></td></tr>
<tr class="memitem:ab83da8da989fe41693d78d982c7ae6b7"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab83da8da989fe41693d78d982c7ae6b7">rd_kafka_brokers_add</a> (rd_kafka_t *rk, const char *brokerlist)</td></tr>
<tr class="memdesc:ab83da8da989fe41693d78d982c7ae6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one or more brokers to the kafka handle's list of initial bootstrap brokers.  <a href="#ab83da8da989fe41693d78d982c7ae6b7">More...</a><br/></td></tr>
<tr class="separator:ab83da8da989fe41693d78d982c7ae6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4af9adee414af74c7817403f7c4a53"><td class="memItemLeft" align="right" valign="top">RD_EXPORT RD_DEPRECATED void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a9e4af9adee414af74c7817403f7c4a53">rd_kafka_set_logger</a> (rd_kafka_t *rk, void(*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf))</td></tr>
<tr class="memdesc:a9e4af9adee414af74c7817403f7c4a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set logger function.  <a href="#a9e4af9adee414af74c7817403f7c4a53">More...</a><br/></td></tr>
<tr class="separator:a9e4af9adee414af74c7817403f7c4a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acadeefced6bb60acd27e7a0dad553aa4"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#acadeefced6bb60acd27e7a0dad553aa4">rd_kafka_set_log_level</a> (rd_kafka_t *rk, int level)</td></tr>
<tr class="memdesc:acadeefced6bb60acd27e7a0dad553aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the maximum logging level produced by internal kafka logging and debugging.  <a href="#acadeefced6bb60acd27e7a0dad553aa4">More...</a><br/></td></tr>
<tr class="separator:acadeefced6bb60acd27e7a0dad553aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d37a5cef2d6aa0077fdfd23e3020ca7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d37a5cef2d6aa0077fdfd23e3020ca7"></a>
RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a3d37a5cef2d6aa0077fdfd23e3020ca7">rd_kafka_log_print</a> (const rd_kafka_t *rk, int level, const char *fac, const char *buf)</td></tr>
<tr class="memdesc:a3d37a5cef2d6aa0077fdfd23e3020ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builtin (default) log sink: print to stderr. <br/></td></tr>
<tr class="separator:a3d37a5cef2d6aa0077fdfd23e3020ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748d5eaca75f94bb4ff4217ae824385d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a748d5eaca75f94bb4ff4217ae824385d"></a>
RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a748d5eaca75f94bb4ff4217ae824385d">rd_kafka_log_syslog</a> (const rd_kafka_t *rk, int level, const char *fac, const char *buf)</td></tr>
<tr class="memdesc:a748d5eaca75f94bb4ff4217ae824385d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builtin log sink: print to syslog. <br/></td></tr>
<tr class="separator:a748d5eaca75f94bb4ff4217ae824385d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b3b7659cf9a79d3353810d6b625bb7"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ad4b3b7659cf9a79d3353810d6b625bb7">rd_kafka_outq_len</a> (rd_kafka_t *rk)</td></tr>
<tr class="memdesc:ad4b3b7659cf9a79d3353810d6b625bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current out queue length.  <a href="#ad4b3b7659cf9a79d3353810d6b625bb7">More...</a><br/></td></tr>
<tr class="separator:ad4b3b7659cf9a79d3353810d6b625bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a46f74ec4ccc9c0b36dbcf546908a1"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a27a46f74ec4ccc9c0b36dbcf546908a1">rd_kafka_dump</a> (FILE *fp, rd_kafka_t *rk)</td></tr>
<tr class="memdesc:a27a46f74ec4ccc9c0b36dbcf546908a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps rdkafka's internal state for handle <code>rk</code> to stream <code>fp</code>.  <a href="#a27a46f74ec4ccc9c0b36dbcf546908a1">More...</a><br/></td></tr>
<tr class="separator:a27a46f74ec4ccc9c0b36dbcf546908a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0901699375c972b807ba5255773f017f"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0901699375c972b807ba5255773f017f">rd_kafka_thread_cnt</a> (void)</td></tr>
<tr class="memdesc:a0901699375c972b807ba5255773f017f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current number of threads in use by librdkafka.  <a href="#a0901699375c972b807ba5255773f017f">More...</a><br/></td></tr>
<tr class="separator:a0901699375c972b807ba5255773f017f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90f2c92a382dbd0a090d40caa73356d"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aa90f2c92a382dbd0a090d40caa73356d">rd_kafka_wait_destroyed</a> (int timeout_ms)</td></tr>
<tr class="memdesc:aa90f2c92a382dbd0a090d40caa73356d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for all rd_kafka_t objects to be destroyed.  <a href="#aa90f2c92a382dbd0a090d40caa73356d">More...</a><br/></td></tr>
<tr class="separator:aa90f2c92a382dbd0a090d40caa73356d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab932d463be030a5e83ebfc5186ff20b8"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab932d463be030a5e83ebfc5186ff20b8">rd_kafka_unittest</a> (void)</td></tr>
<tr class="memdesc:ab932d463be030a5e83ebfc5186ff20b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run librdkafka's built-in unit-tests.  <a href="#ab932d463be030a5e83ebfc5186ff20b8">More...</a><br/></td></tr>
<tr class="separator:ab932d463be030a5e83ebfc5186ff20b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Experimental APIs</div></td></tr>
<tr class="memitem:a9bfa0a1dd3f866cbf0c82fc089bd7904"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a9bfa0a1dd3f866cbf0c82fc089bd7904">rd_kafka_poll_set_consumer</a> (rd_kafka_t *rk)</td></tr>
<tr class="memdesc:a9bfa0a1dd3f866cbf0c82fc089bd7904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redirect the main (<a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events. ">rd_kafka_poll()</a>) queue to the KafkaConsumer's queue (<a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf" title="Poll the consumer for messages or events. ">rd_kafka_consumer_poll()</a>).  <a href="#a9bfa0a1dd3f866cbf0c82fc089bd7904">More...</a><br/></td></tr>
<tr class="separator:a9bfa0a1dd3f866cbf0c82fc089bd7904"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
librdkafka version</h2></td></tr>
<tr class="memitem:aa2e242fb8620a32b650a40575bc7f98e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e">RD_KAFKA_VERSION</a>&#160;&#160;&#160;0x000b00c9</td></tr>
<tr class="memdesc:aa2e242fb8620a32b650a40575bc7f98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">librdkafka version  <a href="#aa2e242fb8620a32b650a40575bc7f98e">More...</a><br/></td></tr>
<tr class="separator:aa2e242fb8620a32b650a40575bc7f98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e363606ef2da2e91b7429b229dbc8e"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a83e363606ef2da2e91b7429b229dbc8e">rd_kafka_version</a> (void)</td></tr>
<tr class="memdesc:a83e363606ef2da2e91b7429b229dbc8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the librdkafka version as integer.  <a href="#a83e363606ef2da2e91b7429b229dbc8e">More...</a><br/></td></tr>
<tr class="separator:a83e363606ef2da2e91b7429b229dbc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc60434083686fd8e379a905652d34a"><td class="memItemLeft" align="right" valign="top">RD_EXPORT const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0cc60434083686fd8e379a905652d34a">rd_kafka_version_str</a> (void)</td></tr>
<tr class="memdesc:a0cc60434083686fd8e379a905652d34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the librdkafka version as string.  <a href="#a0cc60434083686fd8e379a905652d34a">More...</a><br/></td></tr>
<tr class="separator:a0cc60434083686fd8e379a905652d34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Constants, errors, types</h2></td></tr>
<tr class="memitem:aed25dba90c47adc8ae51d098dca2aed9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aed25dba90c47adc8ae51d098dca2aed9">RD_KAFKA_DEBUG_CONTEXTS</a>&#160;&#160;&#160;&quot;all,generic,broker,topic,metadata,queue,msg,protocol,cgrp,security,fetch,feature&quot;</td></tr>
<tr class="memdesc:aed25dba90c47adc8ae51d098dca2aed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported debug contexts. (compile time)  <a href="#aed25dba90c47adc8ae51d098dca2aed9">More...</a><br/></td></tr>
<tr class="separator:aed25dba90c47adc8ae51d098dca2aed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f9c3cb01cbaf3013689c4f2731b831"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831">rd_kafka_type_t</a> { <br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831ae6134e8d67bee67bfe5e90783f3b9dc8">RD_KAFKA_PRODUCER</a>, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831abdc1bc1d648fb12ee3f7d42de732e049">RD_KAFKA_CONSUMER</a>
<br/>
 }</td></tr>
<tr class="memdesc:ac6f9c3cb01cbaf3013689c4f2731b831"><td class="mdescLeft">&#160;</td><td class="mdescRight">rd_kafka_t handle type.  <a href="rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831">More...</a><br/></td></tr>
<tr class="separator:ac6f9c3cb01cbaf3013689c4f2731b831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7cb459a230a61489234823da2beb3f3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3">rd_kafka_timestamp_type_t</a> { <br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3a9787f345653eaccb6b0020d8eb36d647">RD_KAFKA_TIMESTAMP_NOT_AVAILABLE</a>, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3af59e58fbfe91ffafad1c1b107e32022e">RD_KAFKA_TIMESTAMP_CREATE_TIME</a>, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3afb39205b4fd7d71547c05f94bf8d70a8">RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME</a>
<br/>
 }</td></tr>
<tr class="separator:af7cb459a230a61489234823da2beb3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03509bab51072c72a8dcf52337e6d5cb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> { <br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba2142df2480425e88d9d96b1b08cc7c67">RD_KAFKA_RESP_ERR__BEGIN</a> = -200, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba807f99673a16c6dfc2d6711a142fdf63">RD_KAFKA_RESP_ERR__BAD_MSG</a> = -199, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba83f21df6d9e4919fa6f63f4978d92e31">RD_KAFKA_RESP_ERR__BAD_COMPRESSION</a> = -198, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba9701b1e8dbfd8514773837924607985d">RD_KAFKA_RESP_ERR__DESTROY</a> = -197, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba499a09426c7317e0c8030be5bfadd6a2">RD_KAFKA_RESP_ERR__FAIL</a> = -196, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaa2e905024b42d56f177547ef2c6921f2">RD_KAFKA_RESP_ERR__TRANSPORT</a> = -195, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbad854e2c94bb5b92e83cdbe5d1b1a98ab">RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE</a> = -194, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba86ca698f5d4d99a0d61b0ec62c6ab093">RD_KAFKA_RESP_ERR__RESOLVE</a> = -193, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbacb94a826892b8fef52de2c326f765172">RD_KAFKA_RESP_ERR__MSG_TIMED_OUT</a> = -192, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaffd61f12a5298f508039a9e2521752a5">RD_KAFKA_RESP_ERR__PARTITION_EOF</a> = -191, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba1703a6690b6278c4ce60a7745d81c435">RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION</a> = -190, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba184f6fcda3fe1f6549c45f621dc456bf">RD_KAFKA_RESP_ERR__FS</a> = -189, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbacc9b54e879dba9f6ed3c6e4492a4ae9e">RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC</a> = -188, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbadf1a1cc2d9244d10b5d9b2176da1a7b1">RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN</a> = -187, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba44458ff21ab957663118decae3fe0a31">RD_KAFKA_RESP_ERR__INVALID_ARG</a> = -186, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba191a3d68aab046a25af5e861a5ce394e">RD_KAFKA_RESP_ERR__TIMED_OUT</a> = -185, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba8614bce6b6367c95e05003ed953abefa">RD_KAFKA_RESP_ERR__QUEUE_FULL</a> = -184, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba35e614340fa0417a954a94d9ed252be3">RD_KAFKA_RESP_ERR__ISR_INSUFF</a> = -183, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbad6b23970e00b4575556e8bf6669b1907">RD_KAFKA_RESP_ERR__NODE_UPDATE</a> = -182, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbafa666e504c1c4db6132bb8cc62789bd7">RD_KAFKA_RESP_ERR__SSL</a> = -181, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaff33cdcf5c414f862d30bfc971d9b883">RD_KAFKA_RESP_ERR__WAIT_COORD</a> = -180, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba34f3842df468d18d83eaf06fcb1ec133">RD_KAFKA_RESP_ERR__UNKNOWN_GROUP</a> = -179, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba3aa91f47659cd8db6e526d61bd801bb0">RD_KAFKA_RESP_ERR__IN_PROGRESS</a> = -178, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba7e8c91550c7f80e3bde03d2e2a26a13f">RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS</a> = -177, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba564de373d65dea2640f879b8f38032ba">RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION</a> = -176, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba4eab145a6f57f455bdde22cb94b61e90">RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS</a> = -175, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba52a7ba59b755f419beec0433cb1633bb">RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS</a> = -174, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbab7a5dd3646ae093462cd3bb7add5c591">RD_KAFKA_RESP_ERR__CONFLICT</a> = -173, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba6953cd96832fca9dab355a87dd83ac0d">RD_KAFKA_RESP_ERR__STATE</a> = -172, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba8c92444502a2e12e78e34c293bcdd341">RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL</a> = -171, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba8a4196c480d8dde72c14c390fe94b113">RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED</a> = -170, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba87e67feaf9a884055ca195ece3ccf1c4">RD_KAFKA_RESP_ERR__AUTHENTICATION</a> = -169, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbada22593237070471d4ce1de595d1a0ae">RD_KAFKA_RESP_ERR__NO_OFFSET</a> = -168, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba48d28854717a35c7607ce851a75bcdc7">RD_KAFKA_RESP_ERR__OUTDATED</a> = -167, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbac0bdc2e1ad2796d55446e038af7b24aa">RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE</a> = -166, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbae7d5f35c2cf0641d7952d6cdf8b065ee">RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE</a> = -165, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba86c020648a3e8257a018955196efea23">RD_KAFKA_RESP_ERR__WAIT_CACHE</a> = -164, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaef87b84297d178bfe7938e21916f7283">RD_KAFKA_RESP_ERR__INTR</a> = -163, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba97ca26a246e51745da9d3859f5640839">RD_KAFKA_RESP_ERR__KEY_SERIALIZATION</a> = -162, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba50ccfe49dddd07786207cb0a126ea300">RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION</a> = -161, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaf806877fb6d670e586bffc367f4dec55">RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION</a> = -160, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbad9d20886a20fbace5a8768f5c817cc96">RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION</a> = -159, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaebda7d93e71b33ea682f2cdb2d025c0c">RD_KAFKA_RESP_ERR__END</a> = -100, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbafd4f4e867c50ec320e86871b98b7b15e">RD_KAFKA_RESP_ERR_UNKNOWN</a> = -1, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaeb15f812641343033e3939df4adfff0a">RD_KAFKA_RESP_ERR_NO_ERROR</a> = 0, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaab466ebc9f9efcdbedfef4e57449adf4">RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE</a> = 1, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbadaaa397721f1566aa1befbb42635c6c9">RD_KAFKA_RESP_ERR_INVALID_MSG</a> = 2, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba22f2b9f295640b43bbd20b064931eaa4">RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba4a78c95be9dce44441151db0f064939e">RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE</a> = 4, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba1b8fa864f8174e650a362d6c85c4acac">RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE</a> = 5, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba48f7ea11514f0d02c090a0bf52deabb8">RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION</a> = 6, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba1944ffe5311ce97d4f71133efd5f745f">RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT</a> = 7, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba7021ad7d7486a4a33e19df226908f6f4">RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE</a> = 8, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba550f9d64d5e2d05c61b5f18942832854">RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE</a> = 9, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba2c5f25f8d58662c06485884c62ccd728">RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE</a> = 10, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba901383ac11a5068e5cfa64fe0899ef42">RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH</a> = 11, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbad1ace41b4944aa8510d001cc0750af3d">RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE</a> = 12, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba24a154a4fd4b62b7a7fa77b816561c49">RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION</a> = 13, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba837e05b8dc24415d0cdd24fa90c94c2b">RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS</a> = 14, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba4b2032a44b39cfcf79af6d38cfee53d6">RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE</a> = 15, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbae3cca426eb84d8c987fcd22d93e3b042">RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP</a> = 16, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaffe696a1bb54ec33b8d258a71d138630">RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION</a> = 17, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba2427070db08c0dbf603d7a439ecafa4e">RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE</a> = 18, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba963396ec3f0141e7cd64eb9103ba025a">RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS</a> = 19, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba3c6bd5bd0a338857481157ad58701285">RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND</a> = 20, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba1bcf9b14d3109e0906710f3fedf6bfa0">RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS</a> = 21, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba7ef65ef4b7e4883d37f07edb2b9299cf">RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION</a> = 22, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba3d611434978ee6c5d1e2c031eae22851">RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL</a> = 23, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba617af6d0a3be8be217a6d4097fe08d93">RD_KAFKA_RESP_ERR_INVALID_GROUP_ID</a> = 24, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba98ba2fb36473df8aa20eece119b5c371">RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID</a> = 25, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbacbf57dcb89cbe4e8109009235c3a38a3">RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT</a> = 26, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbafacbf6cd012723e9deeffdbedb086c34">RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS</a> = 27, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbabce6dddfb9449a93d89f5175259b01f5">RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE</a> = 28, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbac3ca8f351f7f49bc644360d70def9d15">RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED</a> = 29, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaf6a3717285b4de6d098778d5abff62d3">RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED</a> = 30, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba91be303afca8631793ae36cd7fa5eb9b">RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED</a> = 31, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaa36b8c17d6e57243b85992c8a4c4fbf8">RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP</a> = 32, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbab6e2e19fa13d5a65dcd0a09cc00e94fa">RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM</a> = 33, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaf2c0ee45c60d46a1dfb209afcbc97e3f">RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE</a> = 34, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba46f16f7c02e3798695feff061acd3f72">RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION</a> = 35, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba2bbe3972fadcb5659de8ba452ba9930d">RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS</a> = 36, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbae389ad18fd247f5194ecd8b06bab8af0">RD_KAFKA_RESP_ERR_INVALID_PARTITIONS</a> = 37, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba79bf494e4989ba2d6ef2d5dfe35e07d4">RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR</a> = 38, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbae2bc328101f522588761a21bd1e92d33">RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT</a> = 39, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba31a534f09b2d2be5e31186ee019be02d">RD_KAFKA_RESP_ERR_INVALID_CONFIG</a> = 40, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba57763f968ed247ada93b95f5871c6421">RD_KAFKA_RESP_ERR_NOT_CONTROLLER</a> = 41, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaa9136aa227a79576e599b693280e47f4">RD_KAFKA_RESP_ERR_INVALID_REQUEST</a> = 42, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba09cc6445761305511ec565a1fb578e63">RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT</a> = 43, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba008f9c1a7d4dbbb7b8629329cb94f4d4">RD_KAFKA_RESP_ERR_POLICY_VIOLATION</a> = 44, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaf78bc9392ecbb491f44f00304db31c5d">RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER</a> = 45, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbac29fba93ef898d51228e3b5254f89e93">RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER</a> = 46, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba246438ea75f6160876ac25460e1e2a76">RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH</a> = 47, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba967df10eecf66034efc36e76eb5d4da8">RD_KAFKA_RESP_ERR_INVALID_TXN_STATE</a> = 48, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba386fa6212eb07e2e81ed0b30d03f975b">RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING</a> = 49, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba0e1a90d8d8a6b03e51d2bdcd61c84977">RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT</a> = 50, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba9cc06f97e19cb867471f4fc3039cb92e">RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS</a> = 51, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba01826892e952e952e5cd0a3a025e3ff3">RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED</a> = 52, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbac8538f30651540470a5d9691cdfeb6ac">RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED</a> = 53, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba3fcd641c7927aee35edd5766bd694ec9">RD_KAFKA_RESP_ERR_SECURITY_DISABLED</a> = 54, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba0c64f1f4d8901d3266ea8bf89f994119">RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED</a> = 55, 
<br/>
&#160;&#160;<b>RD_KAFKA_RESP_ERR_END_ALL</b>
<br/>
 }</td></tr>
<tr class="memdesc:a03509bab51072c72a8dcf52337e6d5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes.  <a href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">More...</a><br/></td></tr>
<tr class="separator:a03509bab51072c72a8dcf52337e6d5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adece97d3cbdd6ca936df5b0663118c45"><td class="memItemLeft" align="right" valign="top">RD_EXPORT const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#adece97d3cbdd6ca936df5b0663118c45">rd_kafka_get_debug_contexts</a> (void)</td></tr>
<tr class="memdesc:adece97d3cbdd6ca936df5b0663118c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve supported debug contexts for use with the <code>"debug"</code> configuration property. (runtime)  <a href="#adece97d3cbdd6ca936df5b0663118c45">More...</a><br/></td></tr>
<tr class="separator:adece97d3cbdd6ca936df5b0663118c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0475de10b4ad6c20f722fcacbd85aacd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0475de10b4ad6c20f722fcacbd85aacd"></a>
RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0475de10b4ad6c20f722fcacbd85aacd">rd_kafka_get_err_descs</a> (const struct <a class="el" href="structrd__kafka__err__desc.html">rd_kafka_err_desc</a> **errdescs, size_t *cntp)</td></tr>
<tr class="memdesc:a0475de10b4ad6c20f722fcacbd85aacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the full list of error codes. <br/></td></tr>
<tr class="separator:a0475de10b4ad6c20f722fcacbd85aacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7bfc925e8d63851511b88a1cee94d6d"><td class="memItemLeft" align="right" valign="top">RD_EXPORT const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab7bfc925e8d63851511b88a1cee94d6d">rd_kafka_err2str</a> (<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err)</td></tr>
<tr class="memdesc:ab7bfc925e8d63851511b88a1cee94d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a human readable representation of a kafka error.  <a href="#ab7bfc925e8d63851511b88a1cee94d6d">More...</a><br/></td></tr>
<tr class="separator:ab7bfc925e8d63851511b88a1cee94d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5f6f2775ec67b124abeb5dfada2d77"><td class="memItemLeft" align="right" valign="top">RD_EXPORT const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a8d5f6f2775ec67b124abeb5dfada2d77">rd_kafka_err2name</a> (<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err)</td></tr>
<tr class="memdesc:a8d5f6f2775ec67b124abeb5dfada2d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error code name (enum name).  <a href="#a8d5f6f2775ec67b124abeb5dfada2d77">More...</a><br/></td></tr>
<tr class="separator:a8d5f6f2775ec67b124abeb5dfada2d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b90c323d460e0276d79f6ab69e93b7"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ae7b90c323d460e0276d79f6ab69e93b7">rd_kafka_last_error</a> (void)</td></tr>
<tr class="memdesc:ae7b90c323d460e0276d79f6ab69e93b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last error code generated by a legacy API call in the current thread.  <a href="#ae7b90c323d460e0276d79f6ab69e93b7">More...</a><br/></td></tr>
<tr class="separator:ae7b90c323d460e0276d79f6ab69e93b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeabf8589c657d7a3ec5a1411a7de91d"><td class="memItemLeft" align="right" valign="top">RD_EXPORT RD_DEPRECATED <br class="typebreak"/>
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#abeabf8589c657d7a3ec5a1411a7de91d">rd_kafka_errno2err</a> (int errnox)</td></tr>
<tr class="memdesc:abeabf8589c657d7a3ec5a1411a7de91d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the system errno value <code>errnox</code> to a rd_kafka_resp_err_t error code upon failure from the following functions:  <a href="#abeabf8589c657d7a3ec5a1411a7de91d">More...</a><br/></td></tr>
<tr class="separator:abeabf8589c657d7a3ec5a1411a7de91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa1b1a41d2fc0c487f519663609df4f"><td class="memItemLeft" align="right" valign="top">RD_EXPORT RD_DEPRECATED int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a8aa1b1a41d2fc0c487f519663609df4f">rd_kafka_errno</a> (void)</td></tr>
<tr class="memdesc:a8aa1b1a41d2fc0c487f519663609df4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the thread-local system errno.  <a href="#a8aa1b1a41d2fc0c487f519663609df4f">More...</a><br/></td></tr>
<tr class="separator:a8aa1b1a41d2fc0c487f519663609df4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a7b02e3af816cfacbcfa6468c40c9a"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ac5a7b02e3af816cfacbcfa6468c40c9a">rd_kafka_topic_partition_destroy</a> (<a class="el" href="structrd__kafka__topic__partition__t.html">rd_kafka_topic_partition_t</a> *rktpar)</td></tr>
<tr class="memdesc:ac5a7b02e3af816cfacbcfa6468c40c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a <a class="el" href="structrd__kafka__topic__partition__t.html" title="Topic+Partition place holder. ">rd_kafka_topic_partition_t</a>.  <a href="#ac5a7b02e3af816cfacbcfa6468c40c9a">More...</a><br/></td></tr>
<tr class="separator:ac5a7b02e3af816cfacbcfa6468c40c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb87d24333b6ad5a7415b06882f06b2a"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <br class="typebreak"/>
<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#afb87d24333b6ad5a7415b06882f06b2a">rd_kafka_topic_partition_list_new</a> (int size)</td></tr>
<tr class="memdesc:afb87d24333b6ad5a7415b06882f06b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new list/vector Topic+Partition container.  <a href="#afb87d24333b6ad5a7415b06882f06b2a">More...</a><br/></td></tr>
<tr class="separator:afb87d24333b6ad5a7415b06882f06b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0ab2640e5e96113ce108ab78f475d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c0ab2640e5e96113ce108ab78f475d0"></a>
RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0c0ab2640e5e96113ce108ab78f475d0">rd_kafka_topic_partition_list_destroy</a> (<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *rkparlist)</td></tr>
<tr class="memdesc:a0c0ab2640e5e96113ce108ab78f475d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all resources used by the list and the list itself. <br/></td></tr>
<tr class="separator:a0c0ab2640e5e96113ce108ab78f475d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123ce30e08b31d4ff0fcf6ebe876173d"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <br class="typebreak"/>
<a class="el" href="structrd__kafka__topic__partition__t.html">rd_kafka_topic_partition_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a123ce30e08b31d4ff0fcf6ebe876173d">rd_kafka_topic_partition_list_add</a> (<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *rktparlist, const char *topic, int32_t partition)</td></tr>
<tr class="memdesc:a123ce30e08b31d4ff0fcf6ebe876173d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add topic+partition to list.  <a href="#a123ce30e08b31d4ff0fcf6ebe876173d">More...</a><br/></td></tr>
<tr class="separator:a123ce30e08b31d4ff0fcf6ebe876173d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6365695de425e7866ddd0c59d704111b"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a6365695de425e7866ddd0c59d704111b">rd_kafka_topic_partition_list_add_range</a> (<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *rktparlist, const char *topic, int32_t start, int32_t stop)</td></tr>
<tr class="memdesc:a6365695de425e7866ddd0c59d704111b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add range of partitions from <code>start</code> to <code>stop</code> inclusive.  <a href="#a6365695de425e7866ddd0c59d704111b">More...</a><br/></td></tr>
<tr class="separator:a6365695de425e7866ddd0c59d704111b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a8195aa5f0195d020494bced858a97"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a94a8195aa5f0195d020494bced858a97">rd_kafka_topic_partition_list_del</a> (<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *rktparlist, const char *topic, int32_t partition)</td></tr>
<tr class="memdesc:a94a8195aa5f0195d020494bced858a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete partition from list.  <a href="#a94a8195aa5f0195d020494bced858a97">More...</a><br/></td></tr>
<tr class="separator:a94a8195aa5f0195d020494bced858a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8476ebf3c2f54ddee53e0863feb85463"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a8476ebf3c2f54ddee53e0863feb85463">rd_kafka_topic_partition_list_del_by_idx</a> (<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *rktparlist, int idx)</td></tr>
<tr class="memdesc:a8476ebf3c2f54ddee53e0863feb85463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete partition from list by elems[] index.  <a href="#a8476ebf3c2f54ddee53e0863feb85463">More...</a><br/></td></tr>
<tr class="separator:a8476ebf3c2f54ddee53e0863feb85463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fd3f8c00ffbd0ea740a638dd0a95f7"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <br class="typebreak"/>
<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a66fd3f8c00ffbd0ea740a638dd0a95f7">rd_kafka_topic_partition_list_copy</a> (const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *src)</td></tr>
<tr class="memdesc:a66fd3f8c00ffbd0ea740a638dd0a95f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a copy of an existing list.  <a href="#a66fd3f8c00ffbd0ea740a638dd0a95f7">More...</a><br/></td></tr>
<tr class="separator:a66fd3f8c00ffbd0ea740a638dd0a95f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102b340b901babb247d2c0a8580a094d"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a102b340b901babb247d2c0a8580a094d">rd_kafka_topic_partition_list_set_offset</a> (<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *rktparlist, const char *topic, int32_t partition, int64_t offset)</td></tr>
<tr class="memdesc:a102b340b901babb247d2c0a8580a094d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set offset to <code>offset</code> for <code>topic</code> and <code>partition</code>.  <a href="#a102b340b901babb247d2c0a8580a094d">More...</a><br/></td></tr>
<tr class="separator:a102b340b901babb247d2c0a8580a094d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25d8e4e58c891bdc533471c210697fa"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <br class="typebreak"/>
<a class="el" href="structrd__kafka__topic__partition__t.html">rd_kafka_topic_partition_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab25d8e4e58c891bdc533471c210697fa">rd_kafka_topic_partition_list_find</a> (<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *rktparlist, const char *topic, int32_t partition)</td></tr>
<tr class="memdesc:ab25d8e4e58c891bdc533471c210697fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find element by <code>topic</code> and <code>partition</code>.  <a href="#ab25d8e4e58c891bdc533471c210697fa">More...</a><br/></td></tr>
<tr class="separator:ab25d8e4e58c891bdc533471c210697fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72ed92794eabf2e7ba1b7be9c94de1f"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab72ed92794eabf2e7ba1b7be9c94de1f">rd_kafka_topic_partition_list_sort</a> (<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *rktparlist, int(*cmp)(const void *a, const void *b, void *opaque), void *opaque)</td></tr>
<tr class="memdesc:ab72ed92794eabf2e7ba1b7be9c94de1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort list using comparator <code>cmp</code>.  <a href="#ab72ed92794eabf2e7ba1b7be9c94de1f">More...</a><br/></td></tr>
<tr class="separator:ab72ed92794eabf2e7ba1b7be9c94de1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Var-arg tag types</h2></td></tr>
<tr class="memitem:a03c74ceba678b4e7a624310160a02165"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a03c74ceba678b4e7a624310160a02165">RD_KAFKA_V_END</a>&#160;&#160;&#160;<a class="el" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba8392cf8f43a2127fc4fbb1ae50af6f8f">RD_KAFKA_VTYPE_END</a></td></tr>
<tr class="memdesc:a03c74ceba678b4e7a624310160a02165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macros for rd_kafka_vtype_t that takes the correct arguments for each vtype.  <a href="#a03c74ceba678b4e7a624310160a02165">More...</a><br/></td></tr>
<tr class="separator:a03c74ceba678b4e7a624310160a02165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7b87a5507f79819059f11ded369786"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a6e7b87a5507f79819059f11ded369786">RD_KAFKA_V_TOPIC</a>(topic)</td></tr>
<tr class="separator:a6e7b87a5507f79819059f11ded369786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fb46a5855c6a2bd0c642fa639bff37"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a64fb46a5855c6a2bd0c642fa639bff37">RD_KAFKA_V_RKT</a>(rkt)</td></tr>
<tr class="separator:a64fb46a5855c6a2bd0c642fa639bff37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ee15fd5d9f441f5b0bba62815ea2f3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab8ee15fd5d9f441f5b0bba62815ea2f3">RD_KAFKA_V_PARTITION</a>(partition)</td></tr>
<tr class="separator:ab8ee15fd5d9f441f5b0bba62815ea2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ec8f37eff67ab3b2321329870d4c08"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ae8ec8f37eff67ab3b2321329870d4c08">RD_KAFKA_V_VALUE</a>(VALUE, LEN)</td></tr>
<tr class="separator:ae8ec8f37eff67ab3b2321329870d4c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7c275dc2b977f4aa761962a4008144"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aac7c275dc2b977f4aa761962a4008144">RD_KAFKA_V_KEY</a>(KEY, LEN)</td></tr>
<tr class="separator:aac7c275dc2b977f4aa761962a4008144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b18233761cb0f59215b49108e41ee9b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a3b18233761cb0f59215b49108e41ee9b">RD_KAFKA_V_OPAQUE</a>(opaque)</td></tr>
<tr class="separator:a3b18233761cb0f59215b49108e41ee9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d50abbc375a50ed9ec26972cf72bb0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a10d50abbc375a50ed9ec26972cf72bb0">RD_KAFKA_V_MSGFLAGS</a>(msgflags)</td></tr>
<tr class="separator:a10d50abbc375a50ed9ec26972cf72bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc05e7e3d017c9a07da61c3edb69f61b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#afc05e7e3d017c9a07da61c3edb69f61b">RD_KAFKA_V_TIMESTAMP</a>(timestamp)</td></tr>
<tr class="separator:afc05e7e3d017c9a07da61c3edb69f61b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aac65afa4c30e6d75550e39f6c1ea6b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b">rd_kafka_vtype_t</a> { <br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba8392cf8f43a2127fc4fbb1ae50af6f8f">RD_KAFKA_VTYPE_END</a>, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba2963e9a4838eb825ad954757a965fd45">RD_KAFKA_VTYPE_TOPIC</a>, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba37f0b8d0b3add4ad93bdf7ef6863abd9">RD_KAFKA_VTYPE_RKT</a>, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba2374c0d8cd0d293aebd40b687db16b12">RD_KAFKA_VTYPE_PARTITION</a>, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6baa5c06c93cea11334ee6fd41379dd849d">RD_KAFKA_VTYPE_VALUE</a>, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba83433ee19c9f47e5f561649ab7768cdf">RD_KAFKA_VTYPE_KEY</a>, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6baa3db5c202df5e978f003cd1c0f1fec29">RD_KAFKA_VTYPE_OPAQUE</a>, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba2f55d9d2b0729843f99c758155e948da">RD_KAFKA_VTYPE_MSGFLAGS</a>, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6baf2f1861778d90a40cf0c498985fbc768">RD_KAFKA_VTYPE_TIMESTAMP</a>
<br/>
 }</td></tr>
<tr class="memdesc:a9aac65afa4c30e6d75550e39f6c1ea6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Var-arg tag types.  <a href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b">More...</a><br/></td></tr>
<tr class="separator:a9aac65afa4c30e6d75550e39f6c1ea6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Configuration interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp3b07a21937d806e0679159e87f933b8e"></a>Main/global configuration property interface </p>
</td></tr>
<tr class="memitem:ad8306a08e59e8e2cbc6abdb84f9689f4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a> { <br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4aa1a1dc8e18c730866165853ad819054e">RD_KAFKA_CONF_UNKNOWN</a> = -2, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4a4461e999ca6c9837a9265dad6f2a0d1e">RD_KAFKA_CONF_INVALID</a> = -1, 
<br/>
&#160;&#160;<a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4a12343fa082ab52164a17130d6b0d0f5b">RD_KAFKA_CONF_OK</a> = 0
<br/>
 }</td></tr>
<tr class="memdesc:ad8306a08e59e8e2cbc6abdb84f9689f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration result type.  <a href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">More...</a><br/></td></tr>
<tr class="separator:ad8306a08e59e8e2cbc6abdb84f9689f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7459bd22e8cfa81aa8c2480a4a0304c"><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_conf_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aa7459bd22e8cfa81aa8c2480a4a0304c">rd_kafka_conf_new</a> (void)</td></tr>
<tr class="memdesc:aa7459bd22e8cfa81aa8c2480a4a0304c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create configuration object.  <a href="#aa7459bd22e8cfa81aa8c2480a4a0304c">More...</a><br/></td></tr>
<tr class="separator:aa7459bd22e8cfa81aa8c2480a4a0304c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3669dacf78c5c0eb536d65cb45d0491"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3669dacf78c5c0eb536d65cb45d0491"></a>
RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#af3669dacf78c5c0eb536d65cb45d0491">rd_kafka_conf_destroy</a> (rd_kafka_conf_t *conf)</td></tr>
<tr class="memdesc:af3669dacf78c5c0eb536d65cb45d0491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a conf object. <br/></td></tr>
<tr class="separator:af3669dacf78c5c0eb536d65cb45d0491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbfe15c6978ff09870e82cb524c673d"><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_conf_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a8cbfe15c6978ff09870e82cb524c673d">rd_kafka_conf_dup</a> (const rd_kafka_conf_t *conf)</td></tr>
<tr class="memdesc:a8cbfe15c6978ff09870e82cb524c673d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy/duplicate of configuration object <code>conf</code>.  <a href="#a8cbfe15c6978ff09870e82cb524c673d">More...</a><br/></td></tr>
<tr class="separator:a8cbfe15c6978ff09870e82cb524c673d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba6e2f87d41f38217eefe920b143189"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ba6e2f87d41f38217eefe920b143189"></a>
RD_EXPORT rd_kafka_conf_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a2ba6e2f87d41f38217eefe920b143189">rd_kafka_conf_dup_filter</a> (const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter)</td></tr>
<tr class="memdesc:a2ba6e2f87d41f38217eefe920b143189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="rdkafka_8h.html#a8cbfe15c6978ff09870e82cb524c673d" title="Creates a copy/duplicate of configuration object conf. ">rd_kafka_conf_dup()</a> but with an array of property name prefixes to filter out (ignore) when copying. <br/></td></tr>
<tr class="separator:a2ba6e2f87d41f38217eefe920b143189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1b319278333e8cdee9442da7f135e8"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#abb1b319278333e8cdee9442da7f135e8">rd_kafka_conf_set</a> (rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size)</td></tr>
<tr class="memdesc:abb1b319278333e8cdee9442da7f135e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a configuration property.  <a href="#abb1b319278333e8cdee9442da7f135e8">More...</a><br/></td></tr>
<tr class="separator:abb1b319278333e8cdee9442da7f135e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe702657b91a99f537f4d772ca9bd839"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe702657b91a99f537f4d772ca9bd839"></a>
RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#abe702657b91a99f537f4d772ca9bd839">rd_kafka_conf_set_events</a> (rd_kafka_conf_t *conf, int events)</td></tr>
<tr class="memdesc:abe702657b91a99f537f4d772ca9bd839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable event sourcing. <code>events</code> is a bitmask of <code>RD_KAFKA_EVENT_*</code> of events to enable for consumption by <code><a class="el" href="rdkafka_8h.html#a2f147ed1c554c9048893fb1adde86dfa" title="Poll a queue for an event for max timeout_ms. ">rd_kafka_queue_poll()</a></code>. <br/></td></tr>
<tr class="separator:abe702657b91a99f537f4d772ca9bd839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075b15c4141784fdc271de217005a41f"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a075b15c4141784fdc271de217005a41f">rd_kafka_conf_set_dr_cb</a> (rd_kafka_conf_t *conf, void(*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err, void *opaque, void *msg_opaque))</td></tr>
<tr class="separator:a075b15c4141784fdc271de217005a41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c9946aee26e10de2661fcf2242ea8a"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ac1c9946aee26e10de2661fcf2242ea8a">rd_kafka_conf_set_dr_msg_cb</a> (rd_kafka_conf_t *conf, void(*dr_msg_cb)(rd_kafka_t *rk, const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *opaque))</td></tr>
<tr class="memdesc:ac1c9946aee26e10de2661fcf2242ea8a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Producer:</b> Set delivery report callback in provided <code>conf</code> object.  <a href="#ac1c9946aee26e10de2661fcf2242ea8a">More...</a><br/></td></tr>
<tr class="separator:ac1c9946aee26e10de2661fcf2242ea8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65eaf45e9b26bcb085f4651634ce06a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65eaf45e9b26bcb085f4651634ce06a5"></a>
RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a65eaf45e9b26bcb085f4651634ce06a5">rd_kafka_conf_set_consume_cb</a> (rd_kafka_conf_t *conf, void(*consume_cb)(<a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *opaque))</td></tr>
<tr class="memdesc:a65eaf45e9b26bcb085f4651634ce06a5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Consumer:</b> Set consume callback for use with <a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf" title="Poll the consumer for messages or events. ">rd_kafka_consumer_poll()</a> <br/></td></tr>
<tr class="separator:a65eaf45e9b26bcb085f4651634ce06a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10db731dc1a295bd9884e4f8cb199311"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a10db731dc1a295bd9884e4f8cb199311">rd_kafka_conf_set_rebalance_cb</a> (rd_kafka_conf_t *conf, void(*rebalance_cb)(rd_kafka_t *rk, <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *partitions, void *opaque))</td></tr>
<tr class="memdesc:a10db731dc1a295bd9884e4f8cb199311"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Consumer:</b> Set rebalance callback for use with coordinated consumer group balancing.  <a href="#a10db731dc1a295bd9884e4f8cb199311">More...</a><br/></td></tr>
<tr class="separator:a10db731dc1a295bd9884e4f8cb199311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab8bb9e8d8cdd5906f9e060b506f2eb"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a1ab8bb9e8d8cdd5906f9e060b506f2eb">rd_kafka_conf_set_offset_commit_cb</a> (rd_kafka_conf_t *conf, void(*offset_commit_cb)(rd_kafka_t *rk, <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *offsets, void *opaque))</td></tr>
<tr class="memdesc:a1ab8bb9e8d8cdd5906f9e060b506f2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Consumer:</b> Set offset commit callback for use with consumer groups.  <a href="#a1ab8bb9e8d8cdd5906f9e060b506f2eb">More...</a><br/></td></tr>
<tr class="separator:a1ab8bb9e8d8cdd5906f9e060b506f2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace721ef3b7c22d0c111ec747ef039a90"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ace721ef3b7c22d0c111ec747ef039a90">rd_kafka_conf_set_error_cb</a> (rd_kafka_conf_t *conf, void(*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque))</td></tr>
<tr class="memdesc:ace721ef3b7c22d0c111ec747ef039a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set error callback in provided conf object.  <a href="#ace721ef3b7c22d0c111ec747ef039a90">More...</a><br/></td></tr>
<tr class="separator:ace721ef3b7c22d0c111ec747ef039a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04160826ad039d42c10edec456163fa7"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a04160826ad039d42c10edec456163fa7">rd_kafka_conf_set_throttle_cb</a> (rd_kafka_conf_t *conf, void(*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque))</td></tr>
<tr class="memdesc:a04160826ad039d42c10edec456163fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set throttle callback.  <a href="#a04160826ad039d42c10edec456163fa7">More...</a><br/></td></tr>
<tr class="separator:a04160826ad039d42c10edec456163fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ade2ca41f32eb82c6f7e3d4acbe19f"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a06ade2ca41f32eb82c6f7e3d4acbe19f">rd_kafka_conf_set_log_cb</a> (rd_kafka_conf_t *conf, void(*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf))</td></tr>
<tr class="memdesc:a06ade2ca41f32eb82c6f7e3d4acbe19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set logger callback.  <a href="#a06ade2ca41f32eb82c6f7e3d4acbe19f">More...</a><br/></td></tr>
<tr class="separator:a06ade2ca41f32eb82c6f7e3d4acbe19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597d00432e3ca22174d18e7e348fb766"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a597d00432e3ca22174d18e7e348fb766">rd_kafka_conf_set_stats_cb</a> (rd_kafka_conf_t *conf, int(*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque))</td></tr>
<tr class="memdesc:a597d00432e3ca22174d18e7e348fb766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set statistics callback in provided conf object.  <a href="#a597d00432e3ca22174d18e7e348fb766">More...</a><br/></td></tr>
<tr class="separator:a597d00432e3ca22174d18e7e348fb766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0467a6c20d5af69a29a63b530962ecbf"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0467a6c20d5af69a29a63b530962ecbf">rd_kafka_conf_set_socket_cb</a> (rd_kafka_conf_t *conf, int(*socket_cb)(int domain, int type, int protocol, void *opaque))</td></tr>
<tr class="memdesc:a0467a6c20d5af69a29a63b530962ecbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set socket callback.  <a href="#a0467a6c20d5af69a29a63b530962ecbf">More...</a><br/></td></tr>
<tr class="separator:a0467a6c20d5af69a29a63b530962ecbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53dd1b77019324170d0168617fdaf040"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a53dd1b77019324170d0168617fdaf040">rd_kafka_conf_set_connect_cb</a> (rd_kafka_conf_t *conf, int(*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque))</td></tr>
<tr class="memdesc:a53dd1b77019324170d0168617fdaf040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set connect callback.  <a href="#a53dd1b77019324170d0168617fdaf040">More...</a><br/></td></tr>
<tr class="separator:a53dd1b77019324170d0168617fdaf040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55c7ddc46a354e3f57b5b209e5ec3c7"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab55c7ddc46a354e3f57b5b209e5ec3c7">rd_kafka_conf_set_closesocket_cb</a> (rd_kafka_conf_t *conf, int(*closesocket_cb)(int sockfd, void *opaque))</td></tr>
<tr class="memdesc:ab55c7ddc46a354e3f57b5b209e5ec3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set close socket callback.  <a href="#ab55c7ddc46a354e3f57b5b209e5ec3c7">More...</a><br/></td></tr>
<tr class="separator:ab55c7ddc46a354e3f57b5b209e5ec3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467bb7b1ac070fee536227d6ae9cc551"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a467bb7b1ac070fee536227d6ae9cc551">rd_kafka_conf_set_open_cb</a> (rd_kafka_conf_t *conf, int(*open_cb)(const char *pathname, int flags, mode_t mode, void *opaque))</td></tr>
<tr class="memdesc:a467bb7b1ac070fee536227d6ae9cc551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set open callback.  <a href="#a467bb7b1ac070fee536227d6ae9cc551">More...</a><br/></td></tr>
<tr class="separator:a467bb7b1ac070fee536227d6ae9cc551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cb7d91d9b7458a95ca6f1292763c24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07cb7d91d9b7458a95ca6f1292763c24"></a>
RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a07cb7d91d9b7458a95ca6f1292763c24">rd_kafka_conf_set_opaque</a> (rd_kafka_conf_t *conf, void *opaque)</td></tr>
<tr class="memdesc:a07cb7d91d9b7458a95ca6f1292763c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the application's opaque pointer that will be passed to callbacks. <br/></td></tr>
<tr class="separator:a07cb7d91d9b7458a95ca6f1292763c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af006d797a3db9c80d9bc08b2d4af93da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af006d797a3db9c80d9bc08b2d4af93da"></a>
RD_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#af006d797a3db9c80d9bc08b2d4af93da">rd_kafka_opaque</a> (const rd_kafka_t *rk)</td></tr>
<tr class="memdesc:af006d797a3db9c80d9bc08b2d4af93da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the opaque pointer previously set with <a class="el" href="rdkafka_8h.html#a07cb7d91d9b7458a95ca6f1292763c24" title="Sets the application&#39;s opaque pointer that will be passed to callbacks. ">rd_kafka_conf_set_opaque()</a> <br/></td></tr>
<tr class="separator:af006d797a3db9c80d9bc08b2d4af93da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138aa4881c8703dd6b69f22ddc454f63"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a138aa4881c8703dd6b69f22ddc454f63">rd_kafka_conf_set_default_topic_conf</a> (rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf)</td></tr>
<tr class="separator:a138aa4881c8703dd6b69f22ddc454f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9f0f77e9145eb1a62c3258ac495b97"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#abe9f0f77e9145eb1a62c3258ac495b97">rd_kafka_conf_get</a> (const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size)</td></tr>
<tr class="memdesc:abe9f0f77e9145eb1a62c3258ac495b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve configuration value for property <code>name</code>.  <a href="#abe9f0f77e9145eb1a62c3258ac495b97">More...</a><br/></td></tr>
<tr class="separator:abe9f0f77e9145eb1a62c3258ac495b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56939e7f77106b9e810d59289443e25d"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a56939e7f77106b9e810d59289443e25d">rd_kafka_topic_conf_get</a> (const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size)</td></tr>
<tr class="memdesc:a56939e7f77106b9e810d59289443e25d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve topic configuration value for property <code>name</code>.  <a href="#a56939e7f77106b9e810d59289443e25d">More...</a><br/></td></tr>
<tr class="separator:a56939e7f77106b9e810d59289443e25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eba851c2af748de6921d708b47dc94c"><td class="memItemLeft" align="right" valign="top">RD_EXPORT const char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a6eba851c2af748de6921d708b47dc94c">rd_kafka_conf_dump</a> (rd_kafka_conf_t *conf, size_t *cntp)</td></tr>
<tr class="memdesc:a6eba851c2af748de6921d708b47dc94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the configuration properties and values of <code>conf</code> to an array with "key", "value" pairs.  <a href="#a6eba851c2af748de6921d708b47dc94c">More...</a><br/></td></tr>
<tr class="separator:a6eba851c2af748de6921d708b47dc94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a7a88bd5ac81b21c45d1fdd4d9e696"><td class="memItemLeft" align="right" valign="top">RD_EXPORT const char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a40a7a88bd5ac81b21c45d1fdd4d9e696">rd_kafka_topic_conf_dump</a> (rd_kafka_topic_conf_t *conf, size_t *cntp)</td></tr>
<tr class="memdesc:a40a7a88bd5ac81b21c45d1fdd4d9e696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the topic configuration properties and values of <code>conf</code> to an array with "key", "value" pairs.  <a href="#a40a7a88bd5ac81b21c45d1fdd4d9e696">More...</a><br/></td></tr>
<tr class="separator:a40a7a88bd5ac81b21c45d1fdd4d9e696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fee1254096acd17cbd61cfe70d827e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fee1254096acd17cbd61cfe70d827e5"></a>
RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a8fee1254096acd17cbd61cfe70d827e5">rd_kafka_conf_dump_free</a> (const char **arr, size_t cnt)</td></tr>
<tr class="memdesc:a8fee1254096acd17cbd61cfe70d827e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a configuration dump returned from <code><a class="el" href="rdkafka_8h.html#a6eba851c2af748de6921d708b47dc94c" title="Dump the configuration properties and values of conf to an array with &quot;key&quot;, &quot;value&quot; pairs...">rd_kafka_conf_dump()</a></code> or `rd_kafka_topic_conf_dump(). <br/></td></tr>
<tr class="separator:a8fee1254096acd17cbd61cfe70d827e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52f3a5a08207e14386739fe336e57be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa52f3a5a08207e14386739fe336e57be"></a>
RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aa52f3a5a08207e14386739fe336e57be">rd_kafka_conf_properties_show</a> (FILE *fp)</td></tr>
<tr class="memdesc:aa52f3a5a08207e14386739fe336e57be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a table to <code>fp</code> of all supported configuration properties, their default values as well as a description. <br/></td></tr>
<tr class="separator:aa52f3a5a08207e14386739fe336e57be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Main Kafka and Topic object handles</h2></td></tr>
<tr class="memitem:a3002d1858385de283ea004893e352863"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a3002d1858385de283ea004893e352863">RD_KAFKA_PARTITION_UA</a>&#160;&#160;&#160;((int32_t)-1)</td></tr>
<tr class="memdesc:a3002d1858385de283ea004893e352863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unassigned partition.  <a href="#a3002d1858385de283ea004893e352863">More...</a><br/></td></tr>
<tr class="separator:a3002d1858385de283ea004893e352863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d5cd86ab1f77772b2be170e1c09c24"><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24">rd_kafka_new</a> (<a class="el" href="rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831">rd_kafka_type_t</a> type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size)</td></tr>
<tr class="memdesc:a63d5cd86ab1f77772b2be170e1c09c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Kafka handle and starts its operation according to the specified <code>type</code> (<code>RD_KAFKA_CONSUMER</code> or <code>RD_KAFKA_PRODUCER</code>).  <a href="#a63d5cd86ab1f77772b2be170e1c09c24">More...</a><br/></td></tr>
<tr class="separator:a63d5cd86ab1f77772b2be170e1c09c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac052e92621dcaa3a336dbf826e0d7794"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ac052e92621dcaa3a336dbf826e0d7794">rd_kafka_destroy</a> (rd_kafka_t *rk)</td></tr>
<tr class="memdesc:ac052e92621dcaa3a336dbf826e0d7794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy Kafka handle.  <a href="#ac052e92621dcaa3a336dbf826e0d7794">More...</a><br/></td></tr>
<tr class="separator:ac052e92621dcaa3a336dbf826e0d7794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b15780ab1691b38b7b59e823484e1d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b15780ab1691b38b7b59e823484e1d2"></a>
RD_EXPORT const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a9b15780ab1691b38b7b59e823484e1d2">rd_kafka_name</a> (const rd_kafka_t *rk)</td></tr>
<tr class="memdesc:a9b15780ab1691b38b7b59e823484e1d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Kafka handle name. <br/></td></tr>
<tr class="separator:a9b15780ab1691b38b7b59e823484e1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a4a052441322268b3d787d05d70e74"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6a4a052441322268b3d787d05d70e74"></a>
RD_EXPORT <a class="el" href="rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831">rd_kafka_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab6a4a052441322268b3d787d05d70e74">rd_kafka_type</a> (const rd_kafka_t *rk)</td></tr>
<tr class="memdesc:ab6a4a052441322268b3d787d05d70e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Kafka handle type. <br/></td></tr>
<tr class="separator:ab6a4a052441322268b3d787d05d70e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856d7ecba1aa64e5c89ac92b445cdda6"><td class="memItemLeft" align="right" valign="top">RD_EXPORT char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a856d7ecba1aa64e5c89ac92b445cdda6">rd_kafka_memberid</a> (const rd_kafka_t *rk)</td></tr>
<tr class="memdesc:a856d7ecba1aa64e5c89ac92b445cdda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this client's broker-assigned group member id.  <a href="#a856d7ecba1aa64e5c89ac92b445cdda6">More...</a><br/></td></tr>
<tr class="separator:a856d7ecba1aa64e5c89ac92b445cdda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261ba8c649756fbc7fbcd442ae481a18"><td class="memItemLeft" align="right" valign="top">RD_EXPORT char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a261ba8c649756fbc7fbcd442ae481a18">rd_kafka_clusterid</a> (rd_kafka_t *rk, int timeout_ms)</td></tr>
<tr class="memdesc:a261ba8c649756fbc7fbcd442ae481a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ClusterId as reported in broker metadata.  <a href="#a261ba8c649756fbc7fbcd442ae481a18">More...</a><br/></td></tr>
<tr class="separator:a261ba8c649756fbc7fbcd442ae481a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1dcba74a35e8f3bfe3270ff600581d8"><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_topic_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab1dcba74a35e8f3bfe3270ff600581d8">rd_kafka_topic_new</a> (rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf)</td></tr>
<tr class="memdesc:ab1dcba74a35e8f3bfe3270ff600581d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new topic handle for topic named <code>topic</code>.  <a href="#ab1dcba74a35e8f3bfe3270ff600581d8">More...</a><br/></td></tr>
<tr class="separator:ab1dcba74a35e8f3bfe3270ff600581d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f46cd29d4f9abacd3ee3633c01d8ff"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a91f46cd29d4f9abacd3ee3633c01d8ff">rd_kafka_topic_destroy</a> (rd_kafka_topic_t *rkt)</td></tr>
<tr class="memdesc:a91f46cd29d4f9abacd3ee3633c01d8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loose application's topic handle refcount as previously created with <code><a class="el" href="rdkafka_8h.html#ab1dcba74a35e8f3bfe3270ff600581d8" title="Creates a new topic handle for topic named topic. ">rd_kafka_topic_new()</a></code>.  <a href="#a91f46cd29d4f9abacd3ee3633c01d8ff">More...</a><br/></td></tr>
<tr class="separator:a91f46cd29d4f9abacd3ee3633c01d8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea8248521e63b4afb1d292fbcc584e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ea8248521e63b4afb1d292fbcc584e2"></a>
RD_EXPORT const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a3ea8248521e63b4afb1d292fbcc584e2">rd_kafka_topic_name</a> (const rd_kafka_topic_t *rkt)</td></tr>
<tr class="memdesc:a3ea8248521e63b4afb1d292fbcc584e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the topic name. <br/></td></tr>
<tr class="separator:a3ea8248521e63b4afb1d292fbcc584e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022c498c5593a4bbfa978753cf250aed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a022c498c5593a4bbfa978753cf250aed"></a>
RD_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a022c498c5593a4bbfa978753cf250aed">rd_kafka_topic_opaque</a> (const rd_kafka_topic_t *rkt)</td></tr>
<tr class="memdesc:a022c498c5593a4bbfa978753cf250aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <code>rkt_opaque</code> pointer that was set in the topic configuration. <br/></td></tr>
<tr class="separator:a022c498c5593a4bbfa978753cf250aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50c431e3a29d14da534db49bd0682a4"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4">rd_kafka_poll</a> (rd_kafka_t *rk, int timeout_ms)</td></tr>
<tr class="memdesc:ad50c431e3a29d14da534db49bd0682a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls the provided kafka handle for events.  <a href="#ad50c431e3a29d14da534db49bd0682a4">More...</a><br/></td></tr>
<tr class="separator:ad50c431e3a29d14da534db49bd0682a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111628df6c84716c4b550f8509ac6a6d"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a111628df6c84716c4b550f8509ac6a6d">rd_kafka_yield</a> (rd_kafka_t *rk)</td></tr>
<tr class="memdesc:a111628df6c84716c4b550f8509ac6a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels the current callback dispatcher (<a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events. ">rd_kafka_poll()</a>, <a class="el" href="rdkafka_8h.html#a303fa0f0da7f3c28bed35570adc983c6" title="Consumes messages from topic rkt and partition, calling the provided callback for each consumed messs...">rd_kafka_consume_callback()</a>, etc).  <a href="#a111628df6c84716c4b550f8509ac6a6d">More...</a><br/></td></tr>
<tr class="separator:a111628df6c84716c4b550f8509ac6a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293cb2aac290c157702d3b82f5c14fce"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a293cb2aac290c157702d3b82f5c14fce">rd_kafka_pause_partitions</a> (rd_kafka_t *rk, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *partitions)</td></tr>
<tr class="memdesc:a293cb2aac290c157702d3b82f5c14fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause producing or consumption for the provided list of partitions.  <a href="#a293cb2aac290c157702d3b82f5c14fce">More...</a><br/></td></tr>
<tr class="separator:a293cb2aac290c157702d3b82f5c14fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05819f26887a916ad2047d96a7b4bf2"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ad05819f26887a916ad2047d96a7b4bf2">rd_kafka_resume_partitions</a> (rd_kafka_t *rk, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *partitions)</td></tr>
<tr class="memdesc:ad05819f26887a916ad2047d96a7b4bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume producing consumption for the provided list of partitions.  <a href="#ad05819f26887a916ad2047d96a7b4bf2">More...</a><br/></td></tr>
<tr class="separator:ad05819f26887a916ad2047d96a7b4bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4550ff7d014f08406666124573f70495"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a4550ff7d014f08406666124573f70495">rd_kafka_query_watermark_offsets</a> (rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms)</td></tr>
<tr class="memdesc:a4550ff7d014f08406666124573f70495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query broker for low (oldest/beginning) and high (newest/end) offsets for partition.  <a href="#a4550ff7d014f08406666124573f70495">More...</a><br/></td></tr>
<tr class="separator:a4550ff7d014f08406666124573f70495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d338cebde98a76050e61301f631d82"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ad1d338cebde98a76050e61301f631d82">rd_kafka_get_watermark_offsets</a> (rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high)</td></tr>
<tr class="memdesc:ad1d338cebde98a76050e61301f631d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get last known low (oldest/beginning) and high (newest/end) offsets for partition.  <a href="#ad1d338cebde98a76050e61301f631d82">More...</a><br/></td></tr>
<tr class="separator:ad1d338cebde98a76050e61301f631d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae308aaf534807cfd4c71e423fc214929"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ae308aaf534807cfd4c71e423fc214929">rd_kafka_offsets_for_times</a> (rd_kafka_t *rk, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *offsets, int timeout_ms)</td></tr>
<tr class="memdesc:ae308aaf534807cfd4c71e423fc214929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the offsets for the given partitions by timestamp.  <a href="#ae308aaf534807cfd4c71e423fc214929">More...</a><br/></td></tr>
<tr class="separator:ae308aaf534807cfd4c71e423fc214929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50178b3d3266c9eeb0b5981377833572"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a50178b3d3266c9eeb0b5981377833572">rd_kafka_mem_free</a> (rd_kafka_t *rk, void *ptr)</td></tr>
<tr class="memdesc:a50178b3d3266c9eeb0b5981377833572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free pointer returned by librdkafka.  <a href="#a50178b3d3266c9eeb0b5981377833572">More...</a><br/></td></tr>
<tr class="separator:a50178b3d3266c9eeb0b5981377833572"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Simple Consumer API (legacy)</h2></td></tr>
<tr class="memitem:a32dc6dd93c16e3aac9b89804c4817fba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a32dc6dd93c16e3aac9b89804c4817fba">RD_KAFKA_OFFSET_BEGINNING</a>&#160;&#160;&#160;-2</td></tr>
<tr class="separator:a32dc6dd93c16e3aac9b89804c4817fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7aaaf16e5bd7c0a8a8cb014275c3e06"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aa7aaaf16e5bd7c0a8a8cb014275c3e06">RD_KAFKA_OFFSET_END</a>&#160;&#160;&#160;-1</td></tr>
<tr class="separator:aa7aaaf16e5bd7c0a8a8cb014275c3e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727dc7080140da43adbd5d0b170d49be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a727dc7080140da43adbd5d0b170d49be">RD_KAFKA_OFFSET_STORED</a>&#160;&#160;&#160;-1000</td></tr>
<tr class="separator:a727dc7080140da43adbd5d0b170d49be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e48c4fef9e959ab43cad60ade84af1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ac2e48c4fef9e959ab43cad60ade84af1">RD_KAFKA_OFFSET_INVALID</a>&#160;&#160;&#160;-1001</td></tr>
<tr class="separator:ac2e48c4fef9e959ab43cad60ade84af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26a2522ce2d8ef8ce6c0235e8cfd409"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ae26a2522ce2d8ef8ce6c0235e8cfd409">RD_KAFKA_OFFSET_TAIL</a>(CNT)&#160;&#160;&#160;(RD_KAFKA_OFFSET_TAIL_BASE - (CNT))</td></tr>
<tr class="memdesc:ae26a2522ce2d8ef8ce6c0235e8cfd409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start consuming <code>CNT</code> messages from topic's current end offset.  <a href="#ae26a2522ce2d8ef8ce6c0235e8cfd409">More...</a><br/></td></tr>
<tr class="separator:ae26a2522ce2d8ef8ce6c0235e8cfd409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21dcd2d8c6195baf7f9f4952d7e12d4"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4">rd_kafka_consume_start</a> (rd_kafka_topic_t *rkt, int32_t partition, int64_t offset)</td></tr>
<tr class="memdesc:ae21dcd2d8c6195baf7f9f4952d7e12d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start consuming messages for topic <code>rkt</code> and <code>partition</code> at offset <code>offset</code> which may either be an absolute <code></code>(0..N) or one of the logical offsets:  <a href="#ae21dcd2d8c6195baf7f9f4952d7e12d4">More...</a><br/></td></tr>
<tr class="separator:ae21dcd2d8c6195baf7f9f4952d7e12d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e952d7961169471f69c7ddc87041258"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a8e952d7961169471f69c7ddc87041258">rd_kafka_consume_start_queue</a> (rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu)</td></tr>
<tr class="memdesc:a8e952d7961169471f69c7ddc87041258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4" title="Start consuming messages for topic rkt and partition at offset offset which may either be an absolute...">rd_kafka_consume_start()</a> but re-routes incoming messages to the provided queue <code>rkqu</code> (which must have been previously allocated with <code><a class="el" href="rdkafka_8h.html#a2b59178eb7e88d40510a89f3f2d98b44" title="Create a new message queue. ">rd_kafka_queue_new()</a></code>.  <a href="#a8e952d7961169471f69c7ddc87041258">More...</a><br/></td></tr>
<tr class="separator:a8e952d7961169471f69c7ddc87041258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf07475e5e85e63fc5321a1087288cd4"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#acf07475e5e85e63fc5321a1087288cd4">rd_kafka_consume_stop</a> (rd_kafka_topic_t *rkt, int32_t partition)</td></tr>
<tr class="memdesc:acf07475e5e85e63fc5321a1087288cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop consuming messages for topic <code>rkt</code> and <code>partition</code>, purging all messages currently in the local queue.  <a href="#acf07475e5e85e63fc5321a1087288cd4">More...</a><br/></td></tr>
<tr class="separator:acf07475e5e85e63fc5321a1087288cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6667b162931982e9827e3d86ad22ec7d"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a6667b162931982e9827e3d86ad22ec7d">rd_kafka_seek</a> (rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms)</td></tr>
<tr class="memdesc:a6667b162931982e9827e3d86ad22ec7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek consumer for topic+partition to <code>offset</code> which is either an absolute or logical offset.  <a href="#a6667b162931982e9827e3d86ad22ec7d">More...</a><br/></td></tr>
<tr class="separator:a6667b162931982e9827e3d86ad22ec7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49d14e8b742365f9f25d35318ff0b7e"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e">rd_kafka_consume</a> (rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms)</td></tr>
<tr class="memdesc:aa49d14e8b742365f9f25d35318ff0b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consume a single message from topic <code>rkt</code> and <code>partition</code>.  <a href="#aa49d14e8b742365f9f25d35318ff0b7e">More...</a><br/></td></tr>
<tr class="separator:aa49d14e8b742365f9f25d35318ff0b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53511739a2cf498b8d88287fef6873ce"><td class="memItemLeft" align="right" valign="top">RD_EXPORT ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a53511739a2cf498b8d88287fef6873ce">rd_kafka_consume_batch</a> (rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> **rkmessages, size_t rkmessages_size)</td></tr>
<tr class="memdesc:a53511739a2cf498b8d88287fef6873ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consume up to <code>rkmessages_size</code> from topic <code>rkt</code> and <code>partition</code> putting a pointer to each message in the application provided array <code>rkmessages</code> (of size <code>rkmessages_size</code> entries).  <a href="#a53511739a2cf498b8d88287fef6873ce">More...</a><br/></td></tr>
<tr class="separator:a53511739a2cf498b8d88287fef6873ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303fa0f0da7f3c28bed35570adc983c6"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a303fa0f0da7f3c28bed35570adc983c6">rd_kafka_consume_callback</a> (rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void(*consume_cb)(<a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *opaque), void *opaque)</td></tr>
<tr class="memdesc:a303fa0f0da7f3c28bed35570adc983c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumes messages from topic <code>rkt</code> and <code>partition</code>, calling the provided callback for each consumed messsage.  <a href="#a303fa0f0da7f3c28bed35570adc983c6">More...</a><br/></td></tr>
<tr class="separator:a303fa0f0da7f3c28bed35570adc983c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Producer API</h2></td></tr>
<tr class="memitem:a21be13f8a4cb1d5aff01419f333e5ea7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a21be13f8a4cb1d5aff01419f333e5ea7">RD_KAFKA_MSG_F_FREE</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="memdesc:a21be13f8a4cb1d5aff01419f333e5ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Producer message flags.  <a href="#a21be13f8a4cb1d5aff01419f333e5ea7">More...</a><br/></td></tr>
<tr class="separator:a21be13f8a4cb1d5aff01419f333e5ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7468ab0ece73cc9cb6253a3dcfe702d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ad7468ab0ece73cc9cb6253a3dcfe702d">RD_KAFKA_MSG_F_COPY</a>&#160;&#160;&#160;0x2</td></tr>
<tr class="separator:ad7468ab0ece73cc9cb6253a3dcfe702d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3cdf1c55668f4aa1c2391ddd39c9c2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aca3cdf1c55668f4aa1c2391ddd39c9c2">RD_KAFKA_MSG_F_BLOCK</a>&#160;&#160;&#160;0x4</td></tr>
<tr class="separator:aca3cdf1c55668f4aa1c2391ddd39c9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24d8ebf1ea15ed8ea0ea40f74662736"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ae24d8ebf1ea15ed8ea0ea40f74662736">rd_kafka_produce</a> (rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque)</td></tr>
<tr class="memdesc:ae24d8ebf1ea15ed8ea0ea40f74662736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce and send a single message to broker.  <a href="#ae24d8ebf1ea15ed8ea0ea40f74662736">More...</a><br/></td></tr>
<tr class="separator:ae24d8ebf1ea15ed8ea0ea40f74662736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a111ec3e6729609d498fec7b619efc"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ac3a111ec3e6729609d498fec7b619efc">rd_kafka_producev</a> (rd_kafka_t *rk,...)</td></tr>
<tr class="memdesc:ac3a111ec3e6729609d498fec7b619efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce and send a single message to broker.  <a href="#ac3a111ec3e6729609d498fec7b619efc">More...</a><br/></td></tr>
<tr class="separator:ac3a111ec3e6729609d498fec7b619efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad15c71f228c47946500a0e5c6f88ed"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a7ad15c71f228c47946500a0e5c6f88ed">rd_kafka_produce_batch</a> (rd_kafka_topic_t *rkt, int32_t partition, int msgflags, <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessages, int message_cnt)</td></tr>
<tr class="memdesc:a7ad15c71f228c47946500a0e5c6f88ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce multiple messages.  <a href="#a7ad15c71f228c47946500a0e5c6f88ed">More...</a><br/></td></tr>
<tr class="separator:a7ad15c71f228c47946500a0e5c6f88ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff06c4372bce917c17f3c1a5d8b205d"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aaff06c4372bce917c17f3c1a5d8b205d">rd_kafka_flush</a> (rd_kafka_t *rk, int timeout_ms)</td></tr>
<tr class="memdesc:aaff06c4372bce917c17f3c1a5d8b205d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until all outstanding produce requests, et.al, are completed. This should typically be done prior to destroying a producer instance to make sure all queued and in-flight produce requests are completed before terminating.  <a href="#aaff06c4372bce917c17f3c1a5d8b205d">More...</a><br/></td></tr>
<tr class="separator:aaff06c4372bce917c17f3c1a5d8b205d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Event interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8f8d406360749fdc432d935b2330a31a"></a>The event API provides an alternative pollable non-callback interface to librdkafka's message and event queues. </p>
</td></tr>
<tr class="memitem:aa2707dd1a6225e7649fd5d825284da4d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2707dd1a6225e7649fd5d825284da4d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RD_KAFKA_EVENT_NONE</b>&#160;&#160;&#160;0x0</td></tr>
<tr class="separator:aa2707dd1a6225e7649fd5d825284da4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe880d05ff52138b26dbe8b8e0d2132"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#abfe880d05ff52138b26dbe8b8e0d2132">RD_KAFKA_EVENT_DR</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="separator:abfe880d05ff52138b26dbe8b8e0d2132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfddfd9f3d49591dcd9e7f323dbcd865"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#acfddfd9f3d49591dcd9e7f323dbcd865">RD_KAFKA_EVENT_FETCH</a>&#160;&#160;&#160;0x2</td></tr>
<tr class="separator:acfddfd9f3d49591dcd9e7f323dbcd865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6265a9eeee57e83eb9f3bbd33d92700f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a6265a9eeee57e83eb9f3bbd33d92700f">RD_KAFKA_EVENT_LOG</a>&#160;&#160;&#160;0x4</td></tr>
<tr class="separator:a6265a9eeee57e83eb9f3bbd33d92700f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080a7ad60de643f47424031ee95da103"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a080a7ad60de643f47424031ee95da103">RD_KAFKA_EVENT_ERROR</a>&#160;&#160;&#160;0x8</td></tr>
<tr class="separator:a080a7ad60de643f47424031ee95da103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271e6a5984932015585dd5248535aa2b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a271e6a5984932015585dd5248535aa2b">RD_KAFKA_EVENT_REBALANCE</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="separator:a271e6a5984932015585dd5248535aa2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a29f22b22433a93253a5f77c866437"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a73a29f22b22433a93253a5f77c866437">RD_KAFKA_EVENT_OFFSET_COMMIT</a>&#160;&#160;&#160;0x20</td></tr>
<tr class="separator:a73a29f22b22433a93253a5f77c866437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67070a77150f54039273097c57da5965"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a67070a77150f54039273097c57da5965">RD_KAFKA_EVENT_STATS</a>&#160;&#160;&#160;0x40</td></tr>
<tr class="separator:a67070a77150f54039273097c57da5965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea376a6d5fe278df583e873109b3c2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ea376a6d5fe278df583e873109b3c2f"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a8ea376a6d5fe278df583e873109b3c2f">rd_kafka_event_type_t</a></td></tr>
<tr class="memdesc:a8ea376a6d5fe278df583e873109b3c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event types. <br/></td></tr>
<tr class="separator:a8ea376a6d5fe278df583e873109b3c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b8cda889b33f5901c8aadb6c3e0d81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0b8cda889b33f5901c8aadb6c3e0d81"></a>
typedef struct rd_kafka_op_s&#160;</td><td class="memItemRight" valign="bottom"><b>rd_kafka_event_t</b></td></tr>
<tr class="separator:ae0b8cda889b33f5901c8aadb6c3e0d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108de3729a4aa609a72a458a9de02d1d"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a8ea376a6d5fe278df583e873109b3c2f">rd_kafka_event_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a108de3729a4aa609a72a458a9de02d1d">rd_kafka_event_type</a> (const rd_kafka_event_t *rkev)</td></tr>
<tr class="separator:a108de3729a4aa609a72a458a9de02d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608193d1fb486f78c79497c8c5b63866"><td class="memItemLeft" align="right" valign="top">RD_EXPORT const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a608193d1fb486f78c79497c8c5b63866">rd_kafka_event_name</a> (const rd_kafka_event_t *rkev)</td></tr>
<tr class="separator:a608193d1fb486f78c79497c8c5b63866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1835c85aa202caf629861f29f475099"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#af1835c85aa202caf629861f29f475099">rd_kafka_event_destroy</a> (rd_kafka_event_t *rkev)</td></tr>
<tr class="memdesc:af1835c85aa202caf629861f29f475099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an event.  <a href="#af1835c85aa202caf629861f29f475099">More...</a><br/></td></tr>
<tr class="separator:af1835c85aa202caf629861f29f475099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a855eb7bdf17f5797d4911362a5fc7c"><td class="memItemLeft" align="right" valign="top">RD_EXPORT const <br class="typebreak"/>
<a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a3a855eb7bdf17f5797d4911362a5fc7c">rd_kafka_event_message_next</a> (rd_kafka_event_t *rkev)</td></tr>
<tr class="separator:a3a855eb7bdf17f5797d4911362a5fc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a17000ebe58eabcdafab37924442b8"><td class="memItemLeft" align="right" valign="top">RD_EXPORT size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a18a17000ebe58eabcdafab37924442b8">rd_kafka_event_message_array</a> (rd_kafka_event_t *rkev, const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> **rkmessages, size_t size)</td></tr>
<tr class="memdesc:a18a17000ebe58eabcdafab37924442b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extacts <code>size</code> message(s) from the event into the pre-allocated array <code>rkmessages</code>.  <a href="#a18a17000ebe58eabcdafab37924442b8">More...</a><br/></td></tr>
<tr class="separator:a18a17000ebe58eabcdafab37924442b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d9d106c8956f379bb77d393b8acf90"><td class="memItemLeft" align="right" valign="top">RD_EXPORT size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a61d9d106c8956f379bb77d393b8acf90">rd_kafka_event_message_count</a> (rd_kafka_event_t *rkev)</td></tr>
<tr class="separator:a61d9d106c8956f379bb77d393b8acf90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa28b7d6bb4885843f9a8b9bafa0e15a5"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aa28b7d6bb4885843f9a8b9bafa0e15a5">rd_kafka_event_error</a> (rd_kafka_event_t *rkev)</td></tr>
<tr class="separator:aa28b7d6bb4885843f9a8b9bafa0e15a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76a1b2d6c4f1727725b075678b88793"><td class="memItemLeft" align="right" valign="top">RD_EXPORT const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ad76a1b2d6c4f1727725b075678b88793">rd_kafka_event_error_string</a> (rd_kafka_event_t *rkev)</td></tr>
<tr class="separator:ad76a1b2d6c4f1727725b075678b88793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8650ed2a19108d490a65c9aff3e66525"><td class="memItemLeft" align="right" valign="top">RD_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a8650ed2a19108d490a65c9aff3e66525">rd_kafka_event_opaque</a> (rd_kafka_event_t *rkev)</td></tr>
<tr class="separator:a8650ed2a19108d490a65c9aff3e66525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535efaa16772642d724bedca414c17c7"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a535efaa16772642d724bedca414c17c7">rd_kafka_event_log</a> (rd_kafka_event_t *rkev, const char **fac, const char **str, int *level)</td></tr>
<tr class="memdesc:a535efaa16772642d724bedca414c17c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract log message from the event.  <a href="#a535efaa16772642d724bedca414c17c7">More...</a><br/></td></tr>
<tr class="separator:a535efaa16772642d724bedca414c17c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8572e38ffb452f96d13a2d046fb71d9"><td class="memItemLeft" align="right" valign="top">RD_EXPORT const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ae8572e38ffb452f96d13a2d046fb71d9">rd_kafka_event_stats</a> (rd_kafka_event_t *rkev)</td></tr>
<tr class="memdesc:ae8572e38ffb452f96d13a2d046fb71d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract stats from the event.  <a href="#ae8572e38ffb452f96d13a2d046fb71d9">More...</a><br/></td></tr>
<tr class="separator:ae8572e38ffb452f96d13a2d046fb71d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8f98c9b35be497251fb8515e9e6633"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <br class="typebreak"/>
<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#abc8f98c9b35be497251fb8515e9e6633">rd_kafka_event_topic_partition_list</a> (rd_kafka_event_t *rkev)</td></tr>
<tr class="separator:abc8f98c9b35be497251fb8515e9e6633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4cce46d6e566dd35865c0451b76afe"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <br class="typebreak"/>
<a class="el" href="structrd__kafka__topic__partition__t.html">rd_kafka_topic_partition_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#abf4cce46d6e566dd35865c0451b76afe">rd_kafka_event_topic_partition</a> (rd_kafka_event_t *rkev)</td></tr>
<tr class="separator:abf4cce46d6e566dd35865c0451b76afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f147ed1c554c9048893fb1adde86dfa"><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_event_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a2f147ed1c554c9048893fb1adde86dfa">rd_kafka_queue_poll</a> (rd_kafka_queue_t *rkqu, int timeout_ms)</td></tr>
<tr class="memdesc:a2f147ed1c554c9048893fb1adde86dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll a queue for an event for max <code>timeout_ms</code>.  <a href="#a2f147ed1c554c9048893fb1adde86dfa">More...</a><br/></td></tr>
<tr class="separator:a2f147ed1c554c9048893fb1adde86dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d80084f20a2800e863b97e465ce98e"><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a13d80084f20a2800e863b97e465ce98e">rd_kafka_queue_poll_callback</a> (rd_kafka_queue_t *rkqu, int timeout_ms)</td></tr>
<tr class="memdesc:a13d80084f20a2800e863b97e465ce98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll a queue for events served through callbacks for max <code>timeout_ms</code>.  <a href="#a13d80084f20a2800e863b97e465ce98e">More...</a><br/></td></tr>
<tr class="separator:a13d80084f20a2800e863b97e465ce98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Interceptors</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp27990813574a6790e99690ca6c9443e6"></a>A callback interface that allows message interception for both producer and consumer data pipelines.</p>
<p>Except for the on_new(), on_conf_set(), on_conf_dup() and on_conf_destroy() interceptors, interceptors are added to the newly created rd_kafka_t client instance. These interceptors MUST only be added from on_new() and MUST NOT be added after <a class="el" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24" title="Creates a new Kafka handle and starts its operation according to the specified type (RD_KAFKA_CONSUME...">rd_kafka_new()</a> returns.</p>
<p>The on_new(), on_conf_set(), on_conf_dup() and on_conf_destroy() interceptors are added to the configuration object which is later passed to <a class="el" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24" title="Creates a new Kafka handle and starts its operation according to the specified type (RD_KAFKA_CONSUME...">rd_kafka_new()</a> where on_new() is called to allow addition of other interceptors.</p>
<p>Each interceptor reference consists of a display name (ic_name), a callback function, and an application-specified opaque value that is passed as-is to the callback. The ic_name must be unique for the interceptor implementation and is used to reject duplicate interceptor methods.</p>
<p>Any number of interceptors can be added and they are called in the order they were added, unless otherwise noted. The list of registered interceptor methods are referred to as interceptor chains.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Contrary to the Java client the librdkafka interceptor interface does not support message modification. Message mutability is discouraged in the Java client and the combination of serializers and headers cover most use-cases.</dd>
<dd>
Interceptors are NOT copied to the new configuration on <a class="el" href="rdkafka_8h.html#a8cbfe15c6978ff09870e82cb524c673d" title="Creates a copy/duplicate of configuration object conf. ">rd_kafka_conf_dup()</a> since it would be hard for interceptors to track usage of the interceptor's opaque value. An interceptor should rely on the plugin, which will be copied in rd_kafka_conf_conf_dup(), to set up the initial interceptors. An interceptor should implement the on_conf_dup() method to manually set up its internal configuration on the newly created configuration object that is being copied-to based on the interceptor-specific configuration properties. conf_dup() should thus be treated the same as conf_init().</dd>
<dd>
Interceptors are keyed by the interceptor type (on_..()), the interceptor name (ic_name) and the interceptor method function. Duplicates are not allowed and the .._add_on_..() method will return RD_KAFKA_RESP_ERR__CONFLICT if attempting to add a duplicate method. The only exception is on_conf_destroy() which may be added multiple times by the same interceptor to allow proper cleanup of interceptor configuration state. </dd></dl>
</td></tr>
<tr class="memitem:adb146aa9dbc3a5d4bb4a5b53c1b86b0d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a>(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#adb146aa9dbc3a5d4bb4a5b53c1b86b0d">rd_kafka_interceptor_f_on_conf_set_t</a> )(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque)</td></tr>
<tr class="memdesc:adb146aa9dbc3a5d4bb4a5b53c1b86b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">on_conf_set() is called from rd_kafka_*_conf_set() in the order the interceptors were added.  <a href="#adb146aa9dbc3a5d4bb4a5b53c1b86b0d">More...</a><br/></td></tr>
<tr class="separator:adb146aa9dbc3a5d4bb4a5b53c1b86b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4339f06d7d4d02d06fbc401d279daeb2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a4339f06d7d4d02d06fbc401d279daeb2">rd_kafka_interceptor_f_on_conf_dup_t</a> )(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque)</td></tr>
<tr class="memdesc:a4339f06d7d4d02d06fbc401d279daeb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">on_conf_dup() is called from <a class="el" href="rdkafka_8h.html#a8cbfe15c6978ff09870e82cb524c673d" title="Creates a copy/duplicate of configuration object conf. ">rd_kafka_conf_dup()</a> in the order the interceptors were added and is used to let an interceptor re-register its conf interecptors with a new opaque value. The on_conf_dup() method is called prior to the configuration from <code>old_conf</code> being copied to <code>new_conf</code>.  <a href="#a4339f06d7d4d02d06fbc401d279daeb2">More...</a><br/></td></tr>
<tr class="separator:a4339f06d7d4d02d06fbc401d279daeb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c5416d05a8262ae0a2937853c99257"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a39c5416d05a8262ae0a2937853c99257">rd_kafka_interceptor_f_on_conf_destroy_t</a> )(void *ic_opaque)</td></tr>
<tr class="memdesc:a39c5416d05a8262ae0a2937853c99257"><td class="mdescLeft">&#160;</td><td class="mdescRight">on_conf_destroy() is called from rd_kafka_*_conf_destroy() in the order the interceptors were added.  <a href="#a39c5416d05a8262ae0a2937853c99257">More...</a><br/></td></tr>
<tr class="separator:a39c5416d05a8262ae0a2937853c99257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045854635d67e89de3098a0d5f53cc39"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a045854635d67e89de3098a0d5f53cc39">rd_kafka_interceptor_f_on_new_t</a> )(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size)</td></tr>
<tr class="memdesc:a045854635d67e89de3098a0d5f53cc39"><td class="mdescLeft">&#160;</td><td class="mdescRight">on_new() is called from <a class="el" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24" title="Creates a new Kafka handle and starts its operation according to the specified type (RD_KAFKA_CONSUME...">rd_kafka_new()</a> prior toreturning the newly created client instance to the application.  <a href="#a045854635d67e89de3098a0d5f53cc39">More...</a><br/></td></tr>
<tr class="separator:a045854635d67e89de3098a0d5f53cc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eae9c1d37ab4effd55bb8ed5177ac4d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a3eae9c1d37ab4effd55bb8ed5177ac4d">rd_kafka_interceptor_f_on_destroy_t</a> )(rd_kafka_t *rk, void *ic_opaque)</td></tr>
<tr class="memdesc:a3eae9c1d37ab4effd55bb8ed5177ac4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">on_destroy() is called from <a class="el" href="rdkafka_8h.html#ac052e92621dcaa3a336dbf826e0d7794" title="Destroy Kafka handle. ">rd_kafka_destroy()</a> or (<a class="el" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24" title="Creates a new Kafka handle and starts its operation according to the specified type (RD_KAFKA_CONSUME...">rd_kafka_new()</a> if <a class="el" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24" title="Creates a new Kafka handle and starts its operation according to the specified type (RD_KAFKA_CONSUME...">rd_kafka_new()</a> fails during initialization).  <a href="#a3eae9c1d37ab4effd55bb8ed5177ac4d">More...</a><br/></td></tr>
<tr class="separator:a3eae9c1d37ab4effd55bb8ed5177ac4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b71a63f37c4d94cdb1d05e88f120988"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a4b71a63f37c4d94cdb1d05e88f120988">rd_kafka_interceptor_f_on_send_t</a> )(rd_kafka_t *rk, <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *ic_opaque)</td></tr>
<tr class="memdesc:a4b71a63f37c4d94cdb1d05e88f120988"><td class="mdescLeft">&#160;</td><td class="mdescRight">on_send() is called from rd_kafka_produce*() (et.al) prior to the partitioner being called.  <a href="#a4b71a63f37c4d94cdb1d05e88f120988">More...</a><br/></td></tr>
<tr class="separator:a4b71a63f37c4d94cdb1d05e88f120988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca93ab41df25cab562b9a4cf6c0e7320"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aca93ab41df25cab562b9a4cf6c0e7320">rd_kafka_interceptor_f_on_acknowledgement_t</a> )(rd_kafka_t *rk, <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *ic_opaque)</td></tr>
<tr class="memdesc:aca93ab41df25cab562b9a4cf6c0e7320"><td class="mdescLeft">&#160;</td><td class="mdescRight">on_acknowledgement() is called to inform interceptors that a message was succesfully delivered or permanently failed delivery. The interceptor chain is called from internal librdkafka background threads, or rd_kafka_produce*() if the partitioner failed.  <a href="#aca93ab41df25cab562b9a4cf6c0e7320">More...</a><br/></td></tr>
<tr class="separator:aca93ab41df25cab562b9a4cf6c0e7320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeafe5c26d64281c1f9a2e2f77f774fa4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aeafe5c26d64281c1f9a2e2f77f774fa4">rd_kafka_interceptor_f_on_consume_t</a> )(rd_kafka_t *rk, <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *ic_opaque)</td></tr>
<tr class="memdesc:aeafe5c26d64281c1f9a2e2f77f774fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">on_consume() is called just prior to passing the message to the application in <a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf" title="Poll the consumer for messages or events. ">rd_kafka_consumer_poll()</a>, rd_kafka_consume*(), the event interface, etc.  <a href="#aeafe5c26d64281c1f9a2e2f77f774fa4">More...</a><br/></td></tr>
<tr class="separator:aeafe5c26d64281c1f9a2e2f77f774fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce7c3dfd327ce6512245302be4fe067"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a4ce7c3dfd327ce6512245302be4fe067">rd_kafka_interceptor_f_on_commit_t</a> )(rd_kafka_t *rk, const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *offsets, <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err, void *ic_opaque)</td></tr>
<tr class="memdesc:a4ce7c3dfd327ce6512245302be4fe067"><td class="mdescLeft">&#160;</td><td class="mdescRight">on_commit() is called on completed or failed offset commit. It is called from internal librdkafka threads.  <a href="#a4ce7c3dfd327ce6512245302be4fe067">More...</a><br/></td></tr>
<tr class="separator:a4ce7c3dfd327ce6512245302be4fe067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97bdeb12b99da10eff18767b3cadbfd2"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a97bdeb12b99da10eff18767b3cadbfd2">rd_kafka_conf_interceptor_add_on_conf_set</a> (rd_kafka_conf_t *conf, const char *ic_name, <a class="el" href="rdkafka_8h.html#adb146aa9dbc3a5d4bb4a5b53c1b86b0d">rd_kafka_interceptor_f_on_conf_set_t</a> *on_conf_set, void *ic_opaque)</td></tr>
<tr class="memdesc:a97bdeb12b99da10eff18767b3cadbfd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an on_conf_set() interceptor.  <a href="#a97bdeb12b99da10eff18767b3cadbfd2">More...</a><br/></td></tr>
<tr class="separator:a97bdeb12b99da10eff18767b3cadbfd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375ce703f6247377305dc6a5dfc84429"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a375ce703f6247377305dc6a5dfc84429">rd_kafka_conf_interceptor_add_on_conf_dup</a> (rd_kafka_conf_t *conf, const char *ic_name, <a class="el" href="rdkafka_8h.html#a4339f06d7d4d02d06fbc401d279daeb2">rd_kafka_interceptor_f_on_conf_dup_t</a> *on_conf_dup, void *ic_opaque)</td></tr>
<tr class="memdesc:a375ce703f6247377305dc6a5dfc84429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an on_conf_dup() interceptor.  <a href="#a375ce703f6247377305dc6a5dfc84429">More...</a><br/></td></tr>
<tr class="separator:a375ce703f6247377305dc6a5dfc84429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919ebd487a2717d6cbdf0d25102ea8ff"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a919ebd487a2717d6cbdf0d25102ea8ff">rd_kafka_conf_interceptor_add_on_conf_destroy</a> (rd_kafka_conf_t *conf, const char *ic_name, <a class="el" href="rdkafka_8h.html#a39c5416d05a8262ae0a2937853c99257">rd_kafka_interceptor_f_on_conf_destroy_t</a> *on_conf_destroy, void *ic_opaque)</td></tr>
<tr class="memdesc:a919ebd487a2717d6cbdf0d25102ea8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an on_conf_destroy() interceptor.  <a href="#a919ebd487a2717d6cbdf0d25102ea8ff">More...</a><br/></td></tr>
<tr class="separator:a919ebd487a2717d6cbdf0d25102ea8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002ef1d350176725b6e9ba93548edf40"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a002ef1d350176725b6e9ba93548edf40">rd_kafka_conf_interceptor_add_on_new</a> (rd_kafka_conf_t *conf, const char *ic_name, <a class="el" href="rdkafka_8h.html#a045854635d67e89de3098a0d5f53cc39">rd_kafka_interceptor_f_on_new_t</a> *on_new, void *ic_opaque)</td></tr>
<tr class="memdesc:a002ef1d350176725b6e9ba93548edf40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an on_new() interceptor.  <a href="#a002ef1d350176725b6e9ba93548edf40">More...</a><br/></td></tr>
<tr class="separator:a002ef1d350176725b6e9ba93548edf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b835cb99dc1cfa03c52465b9837a47"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a11b835cb99dc1cfa03c52465b9837a47">rd_kafka_interceptor_add_on_destroy</a> (rd_kafka_t *rk, const char *ic_name, <a class="el" href="rdkafka_8h.html#a3eae9c1d37ab4effd55bb8ed5177ac4d">rd_kafka_interceptor_f_on_destroy_t</a> *on_destroy, void *ic_opaque)</td></tr>
<tr class="memdesc:a11b835cb99dc1cfa03c52465b9837a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an on_destroy() interceptor.  <a href="#a11b835cb99dc1cfa03c52465b9837a47">More...</a><br/></td></tr>
<tr class="separator:a11b835cb99dc1cfa03c52465b9837a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fb1b8884444c63b6930a7bd6122cb6"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#af6fb1b8884444c63b6930a7bd6122cb6">rd_kafka_interceptor_add_on_send</a> (rd_kafka_t *rk, const char *ic_name, <a class="el" href="rdkafka_8h.html#a4b71a63f37c4d94cdb1d05e88f120988">rd_kafka_interceptor_f_on_send_t</a> *on_send, void *ic_opaque)</td></tr>
<tr class="memdesc:af6fb1b8884444c63b6930a7bd6122cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an on_send() interceptor.  <a href="#af6fb1b8884444c63b6930a7bd6122cb6">More...</a><br/></td></tr>
<tr class="separator:af6fb1b8884444c63b6930a7bd6122cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf475ab47fff47ab796be1cecbbd370"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#abaf475ab47fff47ab796be1cecbbd370">rd_kafka_interceptor_add_on_acknowledgement</a> (rd_kafka_t *rk, const char *ic_name, <a class="el" href="rdkafka_8h.html#aca93ab41df25cab562b9a4cf6c0e7320">rd_kafka_interceptor_f_on_acknowledgement_t</a> *on_acknowledgement, void *ic_opaque)</td></tr>
<tr class="memdesc:abaf475ab47fff47ab796be1cecbbd370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an on_acknowledgement() interceptor.  <a href="#abaf475ab47fff47ab796be1cecbbd370">More...</a><br/></td></tr>
<tr class="separator:abaf475ab47fff47ab796be1cecbbd370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e722a9930897bba81b33de5fe95b6ed"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0e722a9930897bba81b33de5fe95b6ed">rd_kafka_interceptor_add_on_consume</a> (rd_kafka_t *rk, const char *ic_name, <a class="el" href="rdkafka_8h.html#aeafe5c26d64281c1f9a2e2f77f774fa4">rd_kafka_interceptor_f_on_consume_t</a> *on_consume, void *ic_opaque)</td></tr>
<tr class="memdesc:a0e722a9930897bba81b33de5fe95b6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an on_consume() interceptor.  <a href="#a0e722a9930897bba81b33de5fe95b6ed">More...</a><br/></td></tr>
<tr class="separator:a0e722a9930897bba81b33de5fe95b6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3e29337dbf11762b5a7e492b77b781"><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0d3e29337dbf11762b5a7e492b77b781">rd_kafka_interceptor_add_on_commit</a> (rd_kafka_t *rk, const char *ic_name, <a class="el" href="rdkafka_8h.html#a4ce7c3dfd327ce6512245302be4fe067">rd_kafka_interceptor_f_on_commit_t</a> *on_commit, void *ic_opaque)</td></tr>
<tr class="memdesc:a0d3e29337dbf11762b5a7e492b77b781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an on_commit() interceptor.  <a href="#a0d3e29337dbf11762b5a7e492b77b781">More...</a><br/></td></tr>
<tr class="separator:a0d3e29337dbf11762b5a7e492b77b781"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Apache Kafka C/C++ consumer and producer client library. </p>
<p><a class="el" href="rdkafka_8h.html" title="Apache Kafka C/C++ consumer and producer client library. ">rdkafka.h</a> contains the public API for librdkafka. The API is documented in this file as comments prefixing the function, type, enum, define, etc.</p>
<dl class="section see"><dt>See Also</dt><dd>For the C++ interface see <a class="el" href="rdkafkacpp_8h.html" title="Apache Kafka C/C++ consumer and producer client library. ">rdkafkacpp.h</a> </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="aa2e242fb8620a32b650a40575bc7f98e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_VERSION&#160;&#160;&#160;0x000b00c9</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="section remark"><dt>Remarks</dt><dd>This value should only be used during compile time, for runtime checks of version use <a class="el" href="rdkafka_8h.html#a83e363606ef2da2e91b7429b229dbc8e" title="Returns the librdkafka version as integer. ">rd_kafka_version()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aed25dba90c47adc8ae51d098dca2aed9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_DEBUG_CONTEXTS&#160;&#160;&#160;&quot;all,generic,broker,topic,metadata,queue,msg,protocol,cgrp,security,fetch,feature&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported debug contexts. (compile time) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>This compile time value may be outdated at runtime due to linking another version of the library. Use <a class="el" href="rdkafka_8h.html#adece97d3cbdd6ca936df5b0663118c45" title="Retrieve supported debug contexts for use with the &quot;debug&quot; configuration property. (runtime) ">rd_kafka_get_debug_contexts()</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a03c74ceba678b4e7a624310160a02165"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_V_END&#160;&#160;&#160;<a class="el" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba8392cf8f43a2127fc4fbb1ae50af6f8f">RD_KAFKA_VTYPE_END</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macros for rd_kafka_vtype_t that takes the correct arguments for each vtype. </p>
<p>va-arg end sentinel used to terminate the variable argument list </p>

</div>
</div>
<a class="anchor" id="a6e7b87a5507f79819059f11ded369786"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_V_TOPIC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">topic</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_LRK_TYPECHECK(<a class="code" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba2963e9a4838eb825ad954757a965fd45">RD_KAFKA_VTYPE_TOPIC</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *, topic),      \</div>
<div class="line">        (<span class="keyword">const</span> <span class="keywordtype">char</span> *)topic</div>
<div class="ttc" id="rdkafka_8h_html_a9aac65afa4c30e6d75550e39f6c1ea6ba2963e9a4838eb825ad954757a965fd45"><div class="ttname"><a href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba2963e9a4838eb825ad954757a965fd45">RD_KAFKA_VTYPE_TOPIC</a></div><div class="ttdef"><b>Definition:</b> rdkafka.h:778</div></div>
</div><!-- fragment --><p>Topic name (const char *) </p>

</div>
</div>
<a class="anchor" id="a64fb46a5855c6a2bd0c642fa639bff37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_V_RKT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rkt</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_LRK_TYPECHECK(<a class="code" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba37f0b8d0b3add4ad93bdf7ef6863abd9">RD_KAFKA_VTYPE_RKT</a>, rd_kafka_topic_t *, rkt),    \</div>
<div class="line">        (rd_kafka_topic_t *)rkt</div>
<div class="ttc" id="rdkafka_8h_html_a9aac65afa4c30e6d75550e39f6c1ea6ba37f0b8d0b3add4ad93bdf7ef6863abd9"><div class="ttname"><a href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba37f0b8d0b3add4ad93bdf7ef6863abd9">RD_KAFKA_VTYPE_RKT</a></div><div class="ttdef"><b>Definition:</b> rdkafka.h:779</div></div>
</div><!-- fragment --><p>Topic object (rd_kafka_topic_t *) </p>

</div>
</div>
<a class="anchor" id="ab8ee15fd5d9f441f5b0bba62815ea2f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_V_PARTITION</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">partition</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_LRK_TYPECHECK(<a class="code" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba2374c0d8cd0d293aebd40b687db16b12">RD_KAFKA_VTYPE_PARTITION</a>, int32_t, partition),   \</div>
<div class="line">        (int32_t)partition</div>
<div class="ttc" id="rdkafka_8h_html_a9aac65afa4c30e6d75550e39f6c1ea6ba2374c0d8cd0d293aebd40b687db16b12"><div class="ttname"><a href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba2374c0d8cd0d293aebd40b687db16b12">RD_KAFKA_VTYPE_PARTITION</a></div><div class="ttdef"><b>Definition:</b> rdkafka.h:780</div></div>
</div><!-- fragment --><p>Partition (int32_t) </p>

</div>
</div>
<a class="anchor" id="ae8ec8f37eff67ab3b2321329870d4c08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_V_VALUE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">VALUE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">LEN&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_LRK_TYPECHECK2(<a class="code" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6baa5c06c93cea11334ee6fd41379dd849d">RD_KAFKA_VTYPE_VALUE</a>, <span class="keywordtype">void</span> *, VALUE, <span class="keywordtype">size_t</span>, LEN), \</div>
<div class="line">        (<span class="keywordtype">void</span> *)VALUE, (<span class="keywordtype">size_t</span>)LEN</div>
<div class="ttc" id="rdkafka_8h_html_a9aac65afa4c30e6d75550e39f6c1ea6baa5c06c93cea11334ee6fd41379dd849d"><div class="ttname"><a href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6baa5c06c93cea11334ee6fd41379dd849d">RD_KAFKA_VTYPE_VALUE</a></div><div class="ttdef"><b>Definition:</b> rdkafka.h:781</div></div>
</div><!-- fragment --><p>Message value/payload pointer and length (void *, size_t) </p>

</div>
</div>
<a class="anchor" id="aac7c275dc2b977f4aa761962a4008144"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_V_KEY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">KEY, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">LEN&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_LRK_TYPECHECK2(<a class="code" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba83433ee19c9f47e5f561649ab7768cdf">RD_KAFKA_VTYPE_KEY</a>, <span class="keyword">const</span> <span class="keywordtype">void</span> *, KEY, <span class="keywordtype">size_t</span>, LEN), \</div>
<div class="line">        (<span class="keywordtype">void</span> *)KEY, (<span class="keywordtype">size_t</span>)LEN</div>
<div class="ttc" id="rdkafka_8h_html_a9aac65afa4c30e6d75550e39f6c1ea6ba83433ee19c9f47e5f561649ab7768cdf"><div class="ttname"><a href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba83433ee19c9f47e5f561649ab7768cdf">RD_KAFKA_VTYPE_KEY</a></div><div class="ttdef"><b>Definition:</b> rdkafka.h:782</div></div>
</div><!-- fragment --><p>Message key pointer and length (const void *, size_t) </p>

</div>
</div>
<a class="anchor" id="a3b18233761cb0f59215b49108e41ee9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_V_OPAQUE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opaque</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_LRK_TYPECHECK(<a class="code" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6baa3db5c202df5e978f003cd1c0f1fec29">RD_KAFKA_VTYPE_OPAQUE</a>, <span class="keywordtype">void</span> *, opaque),    \</div>
<div class="line">        (<span class="keywordtype">void</span> *)opaque</div>
<div class="ttc" id="rdkafka_8h_html_a9aac65afa4c30e6d75550e39f6c1ea6baa3db5c202df5e978f003cd1c0f1fec29"><div class="ttname"><a href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6baa3db5c202df5e978f003cd1c0f1fec29">RD_KAFKA_VTYPE_OPAQUE</a></div><div class="ttdef"><b>Definition:</b> rdkafka.h:783</div></div>
</div><!-- fragment --><p>Opaque pointer (void *) </p>

</div>
</div>
<a class="anchor" id="a10d50abbc375a50ed9ec26972cf72bb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_V_MSGFLAGS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">msgflags</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_LRK_TYPECHECK(<a class="code" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba2f55d9d2b0729843f99c758155e948da">RD_KAFKA_VTYPE_MSGFLAGS</a>, <span class="keywordtype">int</span>, msgflags),       \</div>
<div class="line">        (int)msgflags</div>
<div class="ttc" id="rdkafka_8h_html_a9aac65afa4c30e6d75550e39f6c1ea6ba2f55d9d2b0729843f99c758155e948da"><div class="ttname"><a href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba2f55d9d2b0729843f99c758155e948da">RD_KAFKA_VTYPE_MSGFLAGS</a></div><div class="ttdef"><b>Definition:</b> rdkafka.h:784</div></div>
</div><!-- fragment --><p>Message flags (int) </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="rdkafka_8h.html#ad7468ab0ece73cc9cb6253a3dcfe702d">RD_KAFKA_MSG_F_COPY</a>, et.al. </dd></dl>

</div>
</div>
<a class="anchor" id="afc05e7e3d017c9a07da61c3edb69f61b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_V_TIMESTAMP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timestamp</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">_LRK_TYPECHECK(<a class="code" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6baf2f1861778d90a40cf0c498985fbc768">RD_KAFKA_VTYPE_TIMESTAMP</a>, int64_t, timestamp),   \</div>
<div class="line">        (int64_t)timestamp</div>
<div class="ttc" id="rdkafka_8h_html_a9aac65afa4c30e6d75550e39f6c1ea6baf2f1861778d90a40cf0c498985fbc768"><div class="ttname"><a href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6baf2f1861778d90a40cf0c498985fbc768">RD_KAFKA_VTYPE_TIMESTAMP</a></div><div class="ttdef"><b>Definition:</b> rdkafka.h:785</div></div>
</div><!-- fragment --><p>Timestamp (int64_t) </p>

</div>
</div>
<a class="anchor" id="a3002d1858385de283ea004893e352863"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_PARTITION_UA&#160;&#160;&#160;((int32_t)-1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unassigned partition. </p>
<p>The unassigned partition is used by the producer API for messages that should be partitioned using the configured or default partitioner. </p>

</div>
</div>
<a class="anchor" id="a32dc6dd93c16e3aac9b89804c4817fba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_OFFSET_BEGINNING&#160;&#160;&#160;-2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start consuming from beginning of kafka partition queue: oldest msg </p>

</div>
</div>
<a class="anchor" id="aa7aaaf16e5bd7c0a8a8cb014275c3e06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_OFFSET_END&#160;&#160;&#160;-1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start consuming from end of kafka partition queue: next msg </p>

</div>
</div>
<a class="anchor" id="a727dc7080140da43adbd5d0b170d49be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_OFFSET_STORED&#160;&#160;&#160;-1000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start consuming from offset retrieved from offset store </p>

</div>
</div>
<a class="anchor" id="ac2e48c4fef9e959ab43cad60ade84af1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_OFFSET_INVALID&#160;&#160;&#160;-1001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invalid offset </p>

</div>
</div>
<a class="anchor" id="ae26a2522ce2d8ef8ce6c0235e8cfd409"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_OFFSET_TAIL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">CNT</td><td>)</td>
          <td>&#160;&#160;&#160;(RD_KAFKA_OFFSET_TAIL_BASE - (CNT))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start consuming <code>CNT</code> messages from topic's current end offset. </p>
<p>That is, if current end offset is 12345 and <code>CNT</code> is 200, it will start consuming from offset <code>12345-200</code> = <code>12145</code>. </p>

</div>
</div>
<a class="anchor" id="a21be13f8a4cb1d5aff01419f333e5ea7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_MSG_F_FREE&#160;&#160;&#160;0x1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Producer message flags. </p>
<p>Delegate freeing of payload to rdkafka. </p>

</div>
</div>
<a class="anchor" id="ad7468ab0ece73cc9cb6253a3dcfe702d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_MSG_F_COPY&#160;&#160;&#160;0x2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>rdkafka will make a copy of the payload. </p>

</div>
</div>
<a class="anchor" id="aca3cdf1c55668f4aa1c2391ddd39c9c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_MSG_F_BLOCK&#160;&#160;&#160;0x4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Block produce*() on message queue full. WARNING: If a delivery report callback is used the application MUST call <a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events. ">rd_kafka_poll()</a> (or equiv.) to make sure delivered messages are drained from the internal delivery report queue. Failure to do so will result in indefinately blocking on the produce() call when the message queue is full. </p>

</div>
</div>
<a class="anchor" id="abfe880d05ff52138b26dbe8b8e0d2132"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_EVENT_DR&#160;&#160;&#160;0x1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Producer Delivery report batch </p>

</div>
</div>
<a class="anchor" id="acfddfd9f3d49591dcd9e7f323dbcd865"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_EVENT_FETCH&#160;&#160;&#160;0x2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fetched message (consumer) </p>

</div>
</div>
<a class="anchor" id="a6265a9eeee57e83eb9f3bbd33d92700f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_EVENT_LOG&#160;&#160;&#160;0x4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log message </p>

</div>
</div>
<a class="anchor" id="a080a7ad60de643f47424031ee95da103"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_EVENT_ERROR&#160;&#160;&#160;0x8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Error </p>

</div>
</div>
<a class="anchor" id="a271e6a5984932015585dd5248535aa2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_EVENT_REBALANCE&#160;&#160;&#160;0x10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Group rebalance (consumer) </p>

</div>
</div>
<a class="anchor" id="a73a29f22b22433a93253a5f77c866437"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_EVENT_OFFSET_COMMIT&#160;&#160;&#160;0x20</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offset commit result </p>

</div>
</div>
<a class="anchor" id="a67070a77150f54039273097c57da5965"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_EVENT_STATS&#160;&#160;&#160;0x40</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stats </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a15f8730945790c3c5fb366f2970f73b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>( rd_kafka_plugin_f_conf_init_t)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Plugin's configuration initializer method called each time the library is referenced from configuration (even if previously loaded by another client instance). </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method MUST be implemented by plugins and have the symbol name <code>conf_init</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>Configuration set up to this point. </td></tr>
    <tr><td class="paramname">plug_opaquep</td><td>Plugin can set this pointer to a per-configuration opaque pointer. </td></tr>
    <tr><td class="paramname">errstr</td><td>String buffer of size <code>errstr_size</code> where plugin must write a human readable error string in the case the initializer fails (returns non-zero).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>A plugin may add an on_conf_destroy() interceptor to clean up plugin-specific resources created in the plugin's conf_init() method.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on error. </dd></dl>

</div>
</div>
<a class="anchor" id="adb146aa9dbc3a5d4bb4a5b53c1b86b0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a>( rd_kafka_interceptor_f_on_conf_set_t)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>on_conf_set() is called from rd_kafka_*_conf_set() in the order the interceptors were added. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ic_opaque</td><td>The interceptor's opaque pointer specified in ..add..(). </td></tr>
    <tr><td class="paramname">name</td><td>The configuration property to set. </td></tr>
    <tr><td class="paramname">val</td><td>The configuration value to set, or NULL for reverting to default in which case the previous value should be freed. </td></tr>
    <tr><td class="paramname">errstr</td><td>A human readable error string in case the interceptor fails. </td></tr>
    <tr><td class="paramname">errstr_size</td><td>Maximum space (including \0) in <code>errstr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RD_KAFKA_CONF_RES_OK if the property was known and successfully handled by the interceptor, RD_KAFKA_CONF_RES_INVALID if the property was handled by the interceptor but the value was invalid, or RD_KAFKA_CONF_RES_UNKNOWN if the interceptor did not handle this property, in which case the property is passed on on the interceptor in the chain, finally ending up at the built-in configuration handler. </dd></dl>

</div>
</div>
<a class="anchor" id="a4339f06d7d4d02d06fbc401d279daeb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>( rd_kafka_interceptor_f_on_conf_dup_t)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>on_conf_dup() is called from <a class="el" href="rdkafka_8h.html#a8cbfe15c6978ff09870e82cb524c673d" title="Creates a copy/duplicate of configuration object conf. ">rd_kafka_conf_dup()</a> in the order the interceptors were added and is used to let an interceptor re-register its conf interecptors with a new opaque value. The on_conf_dup() method is called prior to the configuration from <code>old_conf</code> being copied to <code>new_conf</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ic_opaque</td><td>The interceptor's opaque pointer specified in ..add..().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on failure (which is logged but otherwise ignored).</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>No on_conf_* interceptors are copied to the new configuration object on <a class="el" href="rdkafka_8h.html#a8cbfe15c6978ff09870e82cb524c673d" title="Creates a copy/duplicate of configuration object conf. ">rd_kafka_conf_dup()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a39c5416d05a8262ae0a2937853c99257"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>( rd_kafka_interceptor_f_on_conf_destroy_t)(void *ic_opaque)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>on_conf_destroy() is called from rd_kafka_*_conf_destroy() in the order the interceptors were added. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ic_opaque</td><td>The interceptor's opaque pointer specified in ..add..(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a045854635d67e89de3098a0d5f53cc39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>( rd_kafka_interceptor_f_on_new_t)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>on_new() is called from <a class="el" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24" title="Creates a new Kafka handle and starts its operation according to the specified type (RD_KAFKA_CONSUME...">rd_kafka_new()</a> prior toreturning the newly created client instance to the application. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rk</td><td>The client instance. </td></tr>
    <tr><td class="paramname">conf</td><td>The client instance's final configuration. </td></tr>
    <tr><td class="paramname">ic_opaque</td><td>The interceptor's opaque pointer specified in ..add..(). </td></tr>
    <tr><td class="paramname">errstr</td><td>A human readable error string in case the interceptor fails. </td></tr>
    <tr><td class="paramname">errstr_size</td><td>Maximum space (including \0) in <code>errstr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code on failure, the error is logged but otherwise ignored.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The <code>rk</code> client instance will not be fully set up when this interceptor is called and the interceptor MUST NOT call any other rk-specific APIs than rd_kafka_interceptor_add..(). </dd></dl>

</div>
</div>
<a class="anchor" id="a3eae9c1d37ab4effd55bb8ed5177ac4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>( rd_kafka_interceptor_f_on_destroy_t)(rd_kafka_t *rk, void *ic_opaque)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>on_destroy() is called from <a class="el" href="rdkafka_8h.html#ac052e92621dcaa3a336dbf826e0d7794" title="Destroy Kafka handle. ">rd_kafka_destroy()</a> or (<a class="el" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24" title="Creates a new Kafka handle and starts its operation according to the specified type (RD_KAFKA_CONSUME...">rd_kafka_new()</a> if <a class="el" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24" title="Creates a new Kafka handle and starts its operation according to the specified type (RD_KAFKA_CONSUME...">rd_kafka_new()</a> fails during initialization). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rk</td><td>The client instance. </td></tr>
    <tr><td class="paramname">ic_opaque</td><td>The interceptor's opaque pointer specified in ..add..(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b71a63f37c4d94cdb1d05e88f120988"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>( rd_kafka_interceptor_f_on_send_t)(rd_kafka_t *rk, <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *ic_opaque)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>on_send() is called from rd_kafka_produce*() (et.al) prior to the partitioner being called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rk</td><td>The client instance. </td></tr>
    <tr><td class="paramname">rkmessage</td><td>The message being produced. Immutable. </td></tr>
    <tr><td class="paramname">ic_opaque</td><td>The interceptor's opaque pointer specified in ..add..().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This interceptor is only used by producer instances.</dd>
<dd>
The <code>rkmessage</code> object is NOT mutable and MUST NOT be modified by the interceptor.</dd>
<dd>
If the partitioner fails or an unknown partition was specified, the on_acknowledgement() interceptor chain will be called from within the rd_kafka_produce*() call to maintain send-acknowledgement symmetry.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an error code on failure, the error is logged but otherwise ignored. </dd></dl>

</div>
</div>
<a class="anchor" id="aca93ab41df25cab562b9a4cf6c0e7320"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>( rd_kafka_interceptor_f_on_acknowledgement_t)(rd_kafka_t *rk, <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *ic_opaque)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>on_acknowledgement() is called to inform interceptors that a message was succesfully delivered or permanently failed delivery. The interceptor chain is called from internal librdkafka background threads, or rd_kafka_produce*() if the partitioner failed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rk</td><td>The client instance. </td></tr>
    <tr><td class="paramname">rkmessage</td><td>The message being produced. Immutable. </td></tr>
    <tr><td class="paramname">ic_opaque</td><td>The interceptor's opaque pointer specified in ..add..().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This interceptor is only used by producer instances.</dd>
<dd>
The <code>rkmessage</code> object is NOT mutable and MUST NOT be modified by the interceptor.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The on_acknowledgement() method may be called from internal librdkafka threads. An on_acknowledgement() interceptor MUST NOT call any librdkafka API's associated with the <code>rk</code>, or perform any blocking or prolonged work.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an error code on failure, the error is logged but otherwise ignored. </dd></dl>

</div>
</div>
<a class="anchor" id="aeafe5c26d64281c1f9a2e2f77f774fa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>( rd_kafka_interceptor_f_on_consume_t)(rd_kafka_t *rk, <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *ic_opaque)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>on_consume() is called just prior to passing the message to the application in <a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf" title="Poll the consumer for messages or events. ">rd_kafka_consumer_poll()</a>, rd_kafka_consume*(), the event interface, etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rk</td><td>The client instance. </td></tr>
    <tr><td class="paramname">rkmessage</td><td>The message being consumed. Immutable. </td></tr>
    <tr><td class="paramname">ic_opaque</td><td>The interceptor's opaque pointer specified in ..add..().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This interceptor is only used by consumer instances.</dd>
<dd>
The <code>rkmessage</code> object is NOT mutable and MUST NOT be modified by the interceptor.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an error code on failure, the error is logged but otherwise ignored. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ce7c3dfd327ce6512245302be4fe067"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>( rd_kafka_interceptor_f_on_commit_t)(rd_kafka_t *rk, const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *offsets, <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err, void *ic_opaque)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>on_commit() is called on completed or failed offset commit. It is called from internal librdkafka threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rk</td><td>The client instance. </td></tr>
    <tr><td class="paramname">offsets</td><td>List of topic+partition+offset+error that were committed. The error message of each partition should be checked for error. </td></tr>
    <tr><td class="paramname">ic_opaque</td><td>The interceptor's opaque pointer specified in ..add..().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This interceptor is only used by consumer instances.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The on_commit() interceptor is called from internal librdkafka threads. An on_commit() interceptor MUST NOT call any librdkafka API's associated with the <code>rk</code>, or perform any blocking or prolonged work.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an error code on failure, the error is logged but otherwise ignored. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ac6f9c3cb01cbaf3013689c4f2731b831"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831">rd_kafka_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>rd_kafka_t handle type. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24" title="Creates a new Kafka handle and starts its operation according to the specified type (RD_KAFKA_CONSUME...">rd_kafka_new()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ac6f9c3cb01cbaf3013689c4f2731b831ae6134e8d67bee67bfe5e90783f3b9dc8"></a>RD_KAFKA_PRODUCER</em>&nbsp;</td><td class="fielddoc">
<p>Producer client </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ac6f9c3cb01cbaf3013689c4f2731b831abdc1bc1d648fb12ee3f7d42de732e049"></a>RD_KAFKA_CONSUMER</em>&nbsp;</td><td class="fielddoc">
<p>Consumer client </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="af7cb459a230a61489234823da2beb3f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3">rd_kafka_timestamp_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="af7cb459a230a61489234823da2beb3f3a9787f345653eaccb6b0020d8eb36d647"></a>RD_KAFKA_TIMESTAMP_NOT_AVAILABLE</em>&nbsp;</td><td class="fielddoc">
<p>Timestamp not available </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af7cb459a230a61489234823da2beb3f3af59e58fbfe91ffafad1c1b107e32022e"></a>RD_KAFKA_TIMESTAMP_CREATE_TIME</em>&nbsp;</td><td class="fielddoc">
<p>Message creation time </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af7cb459a230a61489234823da2beb3f3afb39205b4fd7d71547c05f94bf8d70a8"></a>RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME</em>&nbsp;</td><td class="fielddoc">
<p>Log append time </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error codes. </p>
<p>The negative error codes delimited by two underscores (<code>RD_KAFKA_RESP_ERR__</code>..) denotes errors internal to librdkafka and are displayed as <code>"Local:</code> &lt;error string..&gt;", while the error codes delimited by a single underscore (<code>RD_KAFKA_RESP_ERR_</code>..) denote broker errors and are displayed as <code>"Broker:</code> &lt;error string..&gt;".</p>
<dl class="section see"><dt>See Also</dt><dd>Use <a class="el" href="rdkafka_8h.html#ab7bfc925e8d63851511b88a1cee94d6d" title="Returns a human readable representation of a kafka error. ">rd_kafka_err2str()</a> to translate an error code a human readable string </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba2142df2480425e88d9d96b1b08cc7c67"></a>RD_KAFKA_RESP_ERR__BEGIN</em>&nbsp;</td><td class="fielddoc">
<p>Begin internal error codes </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba807f99673a16c6dfc2d6711a142fdf63"></a>RD_KAFKA_RESP_ERR__BAD_MSG</em>&nbsp;</td><td class="fielddoc">
<p>Received message is incorrect </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba83f21df6d9e4919fa6f63f4978d92e31"></a>RD_KAFKA_RESP_ERR__BAD_COMPRESSION</em>&nbsp;</td><td class="fielddoc">
<p>Bad/unknown compression </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba9701b1e8dbfd8514773837924607985d"></a>RD_KAFKA_RESP_ERR__DESTROY</em>&nbsp;</td><td class="fielddoc">
<p>Broker is going away </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba499a09426c7317e0c8030be5bfadd6a2"></a>RD_KAFKA_RESP_ERR__FAIL</em>&nbsp;</td><td class="fielddoc">
<p>Generic failure </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaa2e905024b42d56f177547ef2c6921f2"></a>RD_KAFKA_RESP_ERR__TRANSPORT</em>&nbsp;</td><td class="fielddoc">
<p>Broker transport failure </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbad854e2c94bb5b92e83cdbe5d1b1a98ab"></a>RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE</em>&nbsp;</td><td class="fielddoc">
<p>Critical system resource </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba86ca698f5d4d99a0d61b0ec62c6ab093"></a>RD_KAFKA_RESP_ERR__RESOLVE</em>&nbsp;</td><td class="fielddoc">
<p>Failed to resolve broker </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbacb94a826892b8fef52de2c326f765172"></a>RD_KAFKA_RESP_ERR__MSG_TIMED_OUT</em>&nbsp;</td><td class="fielddoc">
<p>Produced message timed out </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaffd61f12a5298f508039a9e2521752a5"></a>RD_KAFKA_RESP_ERR__PARTITION_EOF</em>&nbsp;</td><td class="fielddoc">
<p>Reached the end of the topic+partition queue on the broker. Not really an error. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba1703a6690b6278c4ce60a7745d81c435"></a>RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION</em>&nbsp;</td><td class="fielddoc">
<p>Permanent: Partition does not exist in cluster. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba184f6fcda3fe1f6549c45f621dc456bf"></a>RD_KAFKA_RESP_ERR__FS</em>&nbsp;</td><td class="fielddoc">
<p>File or filesystem error </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbacc9b54e879dba9f6ed3c6e4492a4ae9e"></a>RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC</em>&nbsp;</td><td class="fielddoc">
<p>Permanent: Topic does not exist in cluster. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbadf1a1cc2d9244d10b5d9b2176da1a7b1"></a>RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN</em>&nbsp;</td><td class="fielddoc">
<p>All broker connections are down. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba44458ff21ab957663118decae3fe0a31"></a>RD_KAFKA_RESP_ERR__INVALID_ARG</em>&nbsp;</td><td class="fielddoc">
<p>Invalid argument, or invalid configuration </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba191a3d68aab046a25af5e861a5ce394e"></a>RD_KAFKA_RESP_ERR__TIMED_OUT</em>&nbsp;</td><td class="fielddoc">
<p>Operation timed out </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba8614bce6b6367c95e05003ed953abefa"></a>RD_KAFKA_RESP_ERR__QUEUE_FULL</em>&nbsp;</td><td class="fielddoc">
<p>Queue is full </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba35e614340fa0417a954a94d9ed252be3"></a>RD_KAFKA_RESP_ERR__ISR_INSUFF</em>&nbsp;</td><td class="fielddoc">
<p>ISR count &lt; required.acks </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbad6b23970e00b4575556e8bf6669b1907"></a>RD_KAFKA_RESP_ERR__NODE_UPDATE</em>&nbsp;</td><td class="fielddoc">
<p>Broker node update </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbafa666e504c1c4db6132bb8cc62789bd7"></a>RD_KAFKA_RESP_ERR__SSL</em>&nbsp;</td><td class="fielddoc">
<p>SSL error </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaff33cdcf5c414f862d30bfc971d9b883"></a>RD_KAFKA_RESP_ERR__WAIT_COORD</em>&nbsp;</td><td class="fielddoc">
<p>Waiting for coordinator to become available. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba34f3842df468d18d83eaf06fcb1ec133"></a>RD_KAFKA_RESP_ERR__UNKNOWN_GROUP</em>&nbsp;</td><td class="fielddoc">
<p>Unknown client group </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba3aa91f47659cd8db6e526d61bd801bb0"></a>RD_KAFKA_RESP_ERR__IN_PROGRESS</em>&nbsp;</td><td class="fielddoc">
<p>Operation in progress </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba7e8c91550c7f80e3bde03d2e2a26a13f"></a>RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS</em>&nbsp;</td><td class="fielddoc">
<p>Previous operation in progress, wait for it to finish. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba564de373d65dea2640f879b8f38032ba"></a>RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION</em>&nbsp;</td><td class="fielddoc">
<p>This operation would interfere with an existing subscription </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba4eab145a6f57f455bdde22cb94b61e90"></a>RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS</em>&nbsp;</td><td class="fielddoc">
<p>Assigned partitions (rebalance_cb) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba52a7ba59b755f419beec0433cb1633bb"></a>RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS</em>&nbsp;</td><td class="fielddoc">
<p>Revoked partitions (rebalance_cb) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbab7a5dd3646ae093462cd3bb7add5c591"></a>RD_KAFKA_RESP_ERR__CONFLICT</em>&nbsp;</td><td class="fielddoc">
<p>Conflicting use </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba6953cd96832fca9dab355a87dd83ac0d"></a>RD_KAFKA_RESP_ERR__STATE</em>&nbsp;</td><td class="fielddoc">
<p>Wrong state </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba8c92444502a2e12e78e34c293bcdd341"></a>RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL</em>&nbsp;</td><td class="fielddoc">
<p>Unknown protocol </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba8a4196c480d8dde72c14c390fe94b113"></a>RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED</em>&nbsp;</td><td class="fielddoc">
<p>Not implemented </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba87e67feaf9a884055ca195ece3ccf1c4"></a>RD_KAFKA_RESP_ERR__AUTHENTICATION</em>&nbsp;</td><td class="fielddoc">
<p>Authentication failure </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbada22593237070471d4ce1de595d1a0ae"></a>RD_KAFKA_RESP_ERR__NO_OFFSET</em>&nbsp;</td><td class="fielddoc">
<p>No stored offset </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba48d28854717a35c7607ce851a75bcdc7"></a>RD_KAFKA_RESP_ERR__OUTDATED</em>&nbsp;</td><td class="fielddoc">
<p>Outdated </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbac0bdc2e1ad2796d55446e038af7b24aa"></a>RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE</em>&nbsp;</td><td class="fielddoc">
<p>Timed out in queue </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbae7d5f35c2cf0641d7952d6cdf8b065ee"></a>RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE</em>&nbsp;</td><td class="fielddoc">
<p>Feature not supported by broker </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba86c020648a3e8257a018955196efea23"></a>RD_KAFKA_RESP_ERR__WAIT_CACHE</em>&nbsp;</td><td class="fielddoc">
<p>Awaiting cache update </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaef87b84297d178bfe7938e21916f7283"></a>RD_KAFKA_RESP_ERR__INTR</em>&nbsp;</td><td class="fielddoc">
<p>Operation interrupted (e.g., due to yield)) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba97ca26a246e51745da9d3859f5640839"></a>RD_KAFKA_RESP_ERR__KEY_SERIALIZATION</em>&nbsp;</td><td class="fielddoc">
<p>Key serialization error </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba50ccfe49dddd07786207cb0a126ea300"></a>RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION</em>&nbsp;</td><td class="fielddoc">
<p>Value serialization error </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaf806877fb6d670e586bffc367f4dec55"></a>RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION</em>&nbsp;</td><td class="fielddoc">
<p>Key deserialization error </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbad9d20886a20fbace5a8768f5c817cc96"></a>RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION</em>&nbsp;</td><td class="fielddoc">
<p>Value deserialization error </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaebda7d93e71b33ea682f2cdb2d025c0c"></a>RD_KAFKA_RESP_ERR__END</em>&nbsp;</td><td class="fielddoc">
<p>End internal error codes </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbafd4f4e867c50ec320e86871b98b7b15e"></a>RD_KAFKA_RESP_ERR_UNKNOWN</em>&nbsp;</td><td class="fielddoc">
<p>Unknown broker error </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaeb15f812641343033e3939df4adfff0a"></a>RD_KAFKA_RESP_ERR_NO_ERROR</em>&nbsp;</td><td class="fielddoc">
<p>Success </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaab466ebc9f9efcdbedfef4e57449adf4"></a>RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE</em>&nbsp;</td><td class="fielddoc">
<p>Offset out of range </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbadaaa397721f1566aa1befbb42635c6c9"></a>RD_KAFKA_RESP_ERR_INVALID_MSG</em>&nbsp;</td><td class="fielddoc">
<p>Invalid message </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba22f2b9f295640b43bbd20b064931eaa4"></a>RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART</em>&nbsp;</td><td class="fielddoc">
<p>Unknown topic or partition </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba4a78c95be9dce44441151db0f064939e"></a>RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE</em>&nbsp;</td><td class="fielddoc">
<p>Invalid message size </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba1b8fa864f8174e650a362d6c85c4acac"></a>RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE</em>&nbsp;</td><td class="fielddoc">
<p>Leader not available </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba48f7ea11514f0d02c090a0bf52deabb8"></a>RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION</em>&nbsp;</td><td class="fielddoc">
<p>Not leader for partition </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba1944ffe5311ce97d4f71133efd5f745f"></a>RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT</em>&nbsp;</td><td class="fielddoc">
<p>Request timed out </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba7021ad7d7486a4a33e19df226908f6f4"></a>RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE</em>&nbsp;</td><td class="fielddoc">
<p>Broker not available </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba550f9d64d5e2d05c61b5f18942832854"></a>RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE</em>&nbsp;</td><td class="fielddoc">
<p>Replica not available </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba2c5f25f8d58662c06485884c62ccd728"></a>RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE</em>&nbsp;</td><td class="fielddoc">
<p>Message size too large </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba901383ac11a5068e5cfa64fe0899ef42"></a>RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH</em>&nbsp;</td><td class="fielddoc">
<p>StaleControllerEpochCode </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbad1ace41b4944aa8510d001cc0750af3d"></a>RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE</em>&nbsp;</td><td class="fielddoc">
<p>Offset metadata string too large </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba24a154a4fd4b62b7a7fa77b816561c49"></a>RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION</em>&nbsp;</td><td class="fielddoc">
<p>Broker disconnected before response received </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba837e05b8dc24415d0cdd24fa90c94c2b"></a>RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS</em>&nbsp;</td><td class="fielddoc">
<p>Group coordinator load in progress </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba4b2032a44b39cfcf79af6d38cfee53d6"></a>RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE</em>&nbsp;</td><td class="fielddoc">
<p>Group coordinator not available </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbae3cca426eb84d8c987fcd22d93e3b042"></a>RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP</em>&nbsp;</td><td class="fielddoc">
<p>Not coordinator for group </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaffe696a1bb54ec33b8d258a71d138630"></a>RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION</em>&nbsp;</td><td class="fielddoc">
<p>Invalid topic </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba2427070db08c0dbf603d7a439ecafa4e"></a>RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE</em>&nbsp;</td><td class="fielddoc">
<p>Message batch larger than configured server segment size </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba963396ec3f0141e7cd64eb9103ba025a"></a>RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS</em>&nbsp;</td><td class="fielddoc">
<p>Not enough in-sync replicas </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba3c6bd5bd0a338857481157ad58701285"></a>RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND</em>&nbsp;</td><td class="fielddoc">
<p>Message(s) written to insufficient number of in-sync replicas </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba1bcf9b14d3109e0906710f3fedf6bfa0"></a>RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS</em>&nbsp;</td><td class="fielddoc">
<p>Invalid required acks value </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba7ef65ef4b7e4883d37f07edb2b9299cf"></a>RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION</em>&nbsp;</td><td class="fielddoc">
<p>Specified group generation id is not valid </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba3d611434978ee6c5d1e2c031eae22851"></a>RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL</em>&nbsp;</td><td class="fielddoc">
<p>Inconsistent group protocol </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba617af6d0a3be8be217a6d4097fe08d93"></a>RD_KAFKA_RESP_ERR_INVALID_GROUP_ID</em>&nbsp;</td><td class="fielddoc">
<p>Invalid group.id </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba98ba2fb36473df8aa20eece119b5c371"></a>RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID</em>&nbsp;</td><td class="fielddoc">
<p>Unknown member </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbacbf57dcb89cbe4e8109009235c3a38a3"></a>RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT</em>&nbsp;</td><td class="fielddoc">
<p>Invalid session timeout </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbafacbf6cd012723e9deeffdbedb086c34"></a>RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS</em>&nbsp;</td><td class="fielddoc">
<p>Group rebalance in progress </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbabce6dddfb9449a93d89f5175259b01f5"></a>RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE</em>&nbsp;</td><td class="fielddoc">
<p>Commit offset data size is not valid </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbac3ca8f351f7f49bc644360d70def9d15"></a>RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED</em>&nbsp;</td><td class="fielddoc">
<p>Topic authorization failed </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaf6a3717285b4de6d098778d5abff62d3"></a>RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED</em>&nbsp;</td><td class="fielddoc">
<p>Group authorization failed </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba91be303afca8631793ae36cd7fa5eb9b"></a>RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED</em>&nbsp;</td><td class="fielddoc">
<p>Cluster authorization failed </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaa36b8c17d6e57243b85992c8a4c4fbf8"></a>RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP</em>&nbsp;</td><td class="fielddoc">
<p>Invalid timestamp </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbab6e2e19fa13d5a65dcd0a09cc00e94fa"></a>RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM</em>&nbsp;</td><td class="fielddoc">
<p>Unsupported SASL mechanism </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaf2c0ee45c60d46a1dfb209afcbc97e3f"></a>RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE</em>&nbsp;</td><td class="fielddoc">
<p>Illegal SASL state </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba46f16f7c02e3798695feff061acd3f72"></a>RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION</em>&nbsp;</td><td class="fielddoc">
<p>Unuspported version </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba2bbe3972fadcb5659de8ba452ba9930d"></a>RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS</em>&nbsp;</td><td class="fielddoc">
<p>Topic already exists </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbae389ad18fd247f5194ecd8b06bab8af0"></a>RD_KAFKA_RESP_ERR_INVALID_PARTITIONS</em>&nbsp;</td><td class="fielddoc">
<p>Invalid number of partitions </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba79bf494e4989ba2d6ef2d5dfe35e07d4"></a>RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR</em>&nbsp;</td><td class="fielddoc">
<p>Invalid replication factor </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbae2bc328101f522588761a21bd1e92d33"></a>RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT</em>&nbsp;</td><td class="fielddoc">
<p>Invalid replica assignment </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba31a534f09b2d2be5e31186ee019be02d"></a>RD_KAFKA_RESP_ERR_INVALID_CONFIG</em>&nbsp;</td><td class="fielddoc">
<p>Invalid config </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba57763f968ed247ada93b95f5871c6421"></a>RD_KAFKA_RESP_ERR_NOT_CONTROLLER</em>&nbsp;</td><td class="fielddoc">
<p>Not controller for cluster </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaa9136aa227a79576e599b693280e47f4"></a>RD_KAFKA_RESP_ERR_INVALID_REQUEST</em>&nbsp;</td><td class="fielddoc">
<p>Invalid request </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba09cc6445761305511ec565a1fb578e63"></a>RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT</em>&nbsp;</td><td class="fielddoc">
<p>Message format on broker does not support request </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba008f9c1a7d4dbbb7b8629329cb94f4d4"></a>RD_KAFKA_RESP_ERR_POLICY_VIOLATION</em>&nbsp;</td><td class="fielddoc">
<p>Isolation policy volation </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaf78bc9392ecbb491f44f00304db31c5d"></a>RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER</em>&nbsp;</td><td class="fielddoc">
<p>Broker received an out of order sequence number </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbac29fba93ef898d51228e3b5254f89e93"></a>RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER</em>&nbsp;</td><td class="fielddoc">
<p>Broker received a duplicate sequence number </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba246438ea75f6160876ac25460e1e2a76"></a>RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH</em>&nbsp;</td><td class="fielddoc">
<p>Producer attempted an operation with an old epoch </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba967df10eecf66034efc36e76eb5d4da8"></a>RD_KAFKA_RESP_ERR_INVALID_TXN_STATE</em>&nbsp;</td><td class="fielddoc">
<p>Producer attempted a transactional operation in an invalid state </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba386fa6212eb07e2e81ed0b30d03f975b"></a>RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING</em>&nbsp;</td><td class="fielddoc">
<p>Producer attempted to use a producer id which is not currently assigned to its transactional id </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba0e1a90d8d8a6b03e51d2bdcd61c84977"></a>RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT</em>&nbsp;</td><td class="fielddoc">
<p>Transaction timeout is larger than the maximum value allowed by the broker's max.transaction.timeout.ms </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba9cc06f97e19cb867471f4fc3039cb92e"></a>RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS</em>&nbsp;</td><td class="fielddoc">
<p>Producer attempted to update a transaction while another concurrent operation on the same transaction was ongoing </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba01826892e952e952e5cd0a3a025e3ff3"></a>RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that the transaction coordinator sending a WriteTxnMarker is no longer the current coordinator for a given producer </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbac8538f30651540470a5d9691cdfeb6ac"></a>RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED</em>&nbsp;</td><td class="fielddoc">
<p>Transactional Id authorization failed </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba3fcd641c7927aee35edd5766bd694ec9"></a>RD_KAFKA_RESP_ERR_SECURITY_DISABLED</em>&nbsp;</td><td class="fielddoc">
<p>Security features are disabled </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba0c64f1f4d8901d3266ea8bf89f994119"></a>RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED</em>&nbsp;</td><td class="fielddoc">
<p>Operation not attempted </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a9aac65afa4c30e6d75550e39f6c1ea6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b">rd_kafka_vtype_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Var-arg tag types. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="rdkafka_8h.html#ac3a111ec3e6729609d498fec7b619efc" title="Produce and send a single message to broker. ">rd_kafka_producev()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a9aac65afa4c30e6d75550e39f6c1ea6ba8392cf8f43a2127fc4fbb1ae50af6f8f"></a>RD_KAFKA_VTYPE_END</em>&nbsp;</td><td class="fielddoc">
<p>va-arg sentinel </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9aac65afa4c30e6d75550e39f6c1ea6ba2963e9a4838eb825ad954757a965fd45"></a>RD_KAFKA_VTYPE_TOPIC</em>&nbsp;</td><td class="fielddoc">
<p>(const char *) Topic name </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9aac65afa4c30e6d75550e39f6c1ea6ba37f0b8d0b3add4ad93bdf7ef6863abd9"></a>RD_KAFKA_VTYPE_RKT</em>&nbsp;</td><td class="fielddoc">
<p>(rd_kafka_topic_t *) Topic handle </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9aac65afa4c30e6d75550e39f6c1ea6ba2374c0d8cd0d293aebd40b687db16b12"></a>RD_KAFKA_VTYPE_PARTITION</em>&nbsp;</td><td class="fielddoc">
<p>(int32_t) Partition </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9aac65afa4c30e6d75550e39f6c1ea6baa5c06c93cea11334ee6fd41379dd849d"></a>RD_KAFKA_VTYPE_VALUE</em>&nbsp;</td><td class="fielddoc">
<p>(void *, size_t) Message value (payload) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9aac65afa4c30e6d75550e39f6c1ea6ba83433ee19c9f47e5f561649ab7768cdf"></a>RD_KAFKA_VTYPE_KEY</em>&nbsp;</td><td class="fielddoc">
<p>(void *, size_t) Message key </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9aac65afa4c30e6d75550e39f6c1ea6baa3db5c202df5e978f003cd1c0f1fec29"></a>RD_KAFKA_VTYPE_OPAQUE</em>&nbsp;</td><td class="fielddoc">
<p>(void *) Application opaque </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9aac65afa4c30e6d75550e39f6c1ea6ba2f55d9d2b0729843f99c758155e948da"></a>RD_KAFKA_VTYPE_MSGFLAGS</em>&nbsp;</td><td class="fielddoc">
<p>(int) RD_KAFKA_MSG_F_.. flags </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9aac65afa4c30e6d75550e39f6c1ea6baf2f1861778d90a40cf0c498985fbc768"></a>RD_KAFKA_VTYPE_TIMESTAMP</em>&nbsp;</td><td class="fielddoc">
<p>(int64_t) Milliseconds since epoch UTC </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ad8306a08e59e8e2cbc6abdb84f9689f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configuration result type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ad8306a08e59e8e2cbc6abdb84f9689f4aa1a1dc8e18c730866165853ad819054e"></a>RD_KAFKA_CONF_UNKNOWN</em>&nbsp;</td><td class="fielddoc">
<p>Unknown configuration name. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad8306a08e59e8e2cbc6abdb84f9689f4a4461e999ca6c9837a9265dad6f2a0d1e"></a>RD_KAFKA_CONF_INVALID</em>&nbsp;</td><td class="fielddoc">
<p>Invalid configuration value. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad8306a08e59e8e2cbc6abdb84f9689f4a12343fa082ab52164a17130d6b0d0f5b"></a>RD_KAFKA_CONF_OK</em>&nbsp;</td><td class="fielddoc">
<p>Configuration okay </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a83e363606ef2da2e91b7429b229dbc8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the librdkafka version as integer. </p>
<dl class="section return"><dt>Returns</dt><dd>Version integer.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>See <a class="el" href="rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e" title="librdkafka version ">RD_KAFKA_VERSION</a> for how to parse the integer format. </dd>
<dd>
Use <a class="el" href="rdkafka_8h.html#a0cc60434083686fd8e379a905652d34a" title="Returns the librdkafka version as string. ">rd_kafka_version_str()</a> to retreive the version as a string. </dd></dl>

</div>
</div>
<a class="anchor" id="a0cc60434083686fd8e379a905652d34a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT const char* rd_kafka_version_str </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the librdkafka version as string. </p>
<dl class="section return"><dt>Returns</dt><dd>Version string </dd></dl>

</div>
</div>
<a class="anchor" id="adece97d3cbdd6ca936df5b0663118c45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT const char* rd_kafka_get_debug_contexts </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve supported debug contexts for use with the <code>"debug"</code> configuration property. (runtime) </p>
<dl class="section return"><dt>Returns</dt><dd>Comma-separated list of available debugging contexts. </dd></dl>

</div>
</div>
<a class="anchor" id="ab7bfc925e8d63851511b88a1cee94d6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT const char* rd_kafka_err2str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a human readable representation of a kafka error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>Error code to translate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d5f6f2775ec67b124abeb5dfada2d77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT const char* rd_kafka_err2name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the error code name (enum name). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>Error code to translate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7b90c323d460e0276d79f6ab69e93b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_last_error </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last error code generated by a legacy API call in the current thread. </p>
<p>The legacy APIs are the ones using errno to propagate error value, namely:</p>
<ul>
<li><a class="el" href="rdkafka_8h.html#ab1dcba74a35e8f3bfe3270ff600581d8" title="Creates a new topic handle for topic named topic. ">rd_kafka_topic_new()</a></li>
<li><a class="el" href="rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4" title="Start consuming messages for topic rkt and partition at offset offset which may either be an absolute...">rd_kafka_consume_start()</a></li>
<li><a class="el" href="rdkafka_8h.html#acf07475e5e85e63fc5321a1087288cd4" title="Stop consuming messages for topic rkt and partition, purging all messages currently in the local queu...">rd_kafka_consume_stop()</a></li>
<li><a class="el" href="rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e" title="Consume a single message from topic rkt and partition. ">rd_kafka_consume()</a></li>
<li><a class="el" href="rdkafka_8h.html#a53511739a2cf498b8d88287fef6873ce" title="Consume up to rkmessages_size from topic rkt and partition putting a pointer to each message in the a...">rd_kafka_consume_batch()</a></li>
<li><a class="el" href="rdkafka_8h.html#a303fa0f0da7f3c28bed35570adc983c6" title="Consumes messages from topic rkt and partition, calling the provided callback for each consumed messs...">rd_kafka_consume_callback()</a></li>
<li><a class="el" href="rdkafka_8h.html#a8ff0b80fccb3a5bd31b1baaf20e4ca16" title="Consume from queue. ">rd_kafka_consume_queue()</a></li>
<li><a class="el" href="rdkafka_8h.html#ae24d8ebf1ea15ed8ea0ea40f74662736" title="Produce and send a single message to broker. ">rd_kafka_produce()</a></li>
</ul>
<p>The main use for this function is to avoid converting system <code>errno</code> values to rd_kafka_resp_err_t codes for legacy APIs.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The last error is stored per-thread, if multiple rd_kafka_t handles are used in the same application thread the developer needs to make sure <a class="el" href="rdkafka_8h.html#ae7b90c323d460e0276d79f6ab69e93b7" title="Returns the last error code generated by a legacy API call in the current thread. ...">rd_kafka_last_error()</a> is called immediately after a failed API call.</dd>
<dd>
errno propagation from librdkafka is not safe on Windows and should not be used, use <a class="el" href="rdkafka_8h.html#ae7b90c323d460e0276d79f6ab69e93b7" title="Returns the last error code generated by a legacy API call in the current thread. ...">rd_kafka_last_error()</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="abeabf8589c657d7a3ec5a1411a7de91d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT RD_DEPRECATED <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_errno2err </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>errnox</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the system errno value <code>errnox</code> to a rd_kafka_resp_err_t error code upon failure from the following functions: </p>
<ul>
<li><a class="el" href="rdkafka_8h.html#ab1dcba74a35e8f3bfe3270ff600581d8" title="Creates a new topic handle for topic named topic. ">rd_kafka_topic_new()</a></li>
<li><a class="el" href="rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4" title="Start consuming messages for topic rkt and partition at offset offset which may either be an absolute...">rd_kafka_consume_start()</a></li>
<li><a class="el" href="rdkafka_8h.html#acf07475e5e85e63fc5321a1087288cd4" title="Stop consuming messages for topic rkt and partition, purging all messages currently in the local queu...">rd_kafka_consume_stop()</a></li>
<li><a class="el" href="rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e" title="Consume a single message from topic rkt and partition. ">rd_kafka_consume()</a></li>
<li><a class="el" href="rdkafka_8h.html#a53511739a2cf498b8d88287fef6873ce" title="Consume up to rkmessages_size from topic rkt and partition putting a pointer to each message in the a...">rd_kafka_consume_batch()</a></li>
<li><a class="el" href="rdkafka_8h.html#a303fa0f0da7f3c28bed35570adc983c6" title="Consumes messages from topic rkt and partition, calling the provided callback for each consumed messs...">rd_kafka_consume_callback()</a></li>
<li><a class="el" href="rdkafka_8h.html#a8ff0b80fccb3a5bd31b1baaf20e4ca16" title="Consume from queue. ">rd_kafka_consume_queue()</a></li>
<li><a class="el" href="rdkafka_8h.html#ae24d8ebf1ea15ed8ea0ea40f74662736" title="Produce and send a single message to broker. ">rd_kafka_produce()</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errnox</td><td>System errno value to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Appropriate error code for <code>errnox</code> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>A better alternative is to call <a class="el" href="rdkafka_8h.html#ae7b90c323d460e0276d79f6ab69e93b7" title="Returns the last error code generated by a legacy API call in the current thread. ...">rd_kafka_last_error()</a> immediately after any of the above functions return -1 or NULL.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Use <a class="el" href="rdkafka_8h.html#ae7b90c323d460e0276d79f6ab69e93b7" title="Returns the last error code generated by a legacy API call in the current thread. ...">rd_kafka_last_error()</a> to retrieve the last error code set by the legacy librdkafka APIs.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="rdkafka_8h.html#ae7b90c323d460e0276d79f6ab69e93b7" title="Returns the last error code generated by a legacy API call in the current thread. ...">rd_kafka_last_error()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8aa1b1a41d2fc0c487f519663609df4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT RD_DEPRECATED int rd_kafka_errno </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the thread-local system errno. </p>
<p>On most platforms this is the same as <code>errno</code> but in case of different runtimes between library and application (e.g., Windows static DLLs) this provides a means for exposing the errno librdkafka uses.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The value is local to the current calling thread.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Use <a class="el" href="rdkafka_8h.html#ae7b90c323d460e0276d79f6ab69e93b7" title="Returns the last error code generated by a legacy API call in the current thread. ...">rd_kafka_last_error()</a> to retrieve the last error code set by the legacy librdkafka APIs. </dd></dl>

</div>
</div>
<a class="anchor" id="ac5a7b02e3af816cfacbcfa6468c40c9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_topic_partition_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__t.html">rd_kafka_topic_partition_t</a> *&#160;</td>
          <td class="paramname"><em>rktpar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a <a class="el" href="structrd__kafka__topic__partition__t.html" title="Topic+Partition place holder. ">rd_kafka_topic_partition_t</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This must not be called for elements in a topic partition list. </dd></dl>

</div>
</div>
<a class="anchor" id="afb87d24333b6ad5a7415b06882f06b2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a>* rd_kafka_topic_partition_list_new </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new list/vector Topic+Partition container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Initial allocated size used when the expected number of elements is known or can be estimated. Avoids reallocation and possibly relocation of the elems array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated Topic+Partition list.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Use <a class="el" href="rdkafka_8h.html#a0c0ab2640e5e96113ce108ab78f475d0" title="Free all resources used by the list and the list itself. ">rd_kafka_topic_partition_list_destroy()</a> to free all resources in use by a list and the list itself. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="rdkafka_8h.html#a123ce30e08b31d4ff0fcf6ebe876173d" title="Add topic+partition to list. ">rd_kafka_topic_partition_list_add()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a123ce30e08b31d4ff0fcf6ebe876173d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="structrd__kafka__topic__partition__t.html">rd_kafka_topic_partition_t</a>* rd_kafka_topic_partition_list_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td>
          <td class="paramname"><em>rktparlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add topic+partition to list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rktparlist</td><td>List to extend </td></tr>
    <tr><td class="paramname">topic</td><td>Topic name (copied) </td></tr>
    <tr><td class="paramname">partition</td><td>Partition id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The object which can be used to fill in additionals fields. </dd></dl>

</div>
</div>
<a class="anchor" id="a6365695de425e7866ddd0c59d704111b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_topic_partition_list_add_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td>
          <td class="paramname"><em>rktparlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add range of partitions from <code>start</code> to <code>stop</code> inclusive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rktparlist</td><td>List to extend </td></tr>
    <tr><td class="paramname">topic</td><td>Topic name (copied) </td></tr>
    <tr><td class="paramname">start</td><td>Start partition of range </td></tr>
    <tr><td class="paramname">stop</td><td>Last partition of range (inclusive) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a94a8195aa5f0195d020494bced858a97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_topic_partition_list_del </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td>
          <td class="paramname"><em>rktparlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete partition from list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rktparlist</td><td>List to modify </td></tr>
    <tr><td class="paramname">topic</td><td>Topic name to match </td></tr>
    <tr><td class="paramname">partition</td><td>Partition to match</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if partition was found (and removed), else 0.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Any held indices to elems[] are unusable after this call returns 1. </dd></dl>

</div>
</div>
<a class="anchor" id="a8476ebf3c2f54ddee53e0863feb85463"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_topic_partition_list_del_by_idx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td>
          <td class="paramname"><em>rktparlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete partition from list by elems[] index. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if partition was found (and removed), else 0.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="rdkafka_8h.html#a94a8195aa5f0195d020494bced858a97" title="Delete partition from list. ">rd_kafka_topic_partition_list_del()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a66fd3f8c00ffbd0ea740a638dd0a95f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a>* rd_kafka_topic_partition_list_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a copy of an existing list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The existing list to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new list fully populated to be identical to <code>src</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a102b340b901babb247d2c0a8580a094d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_topic_partition_list_set_offset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td>
          <td class="paramname"><em>rktparlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set offset to <code>offset</code> for <code>topic</code> and <code>partition</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION if <code>partition</code> was not found in the list. </dd></dl>

</div>
</div>
<a class="anchor" id="ab25d8e4e58c891bdc533471c210697fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="structrd__kafka__topic__partition__t.html">rd_kafka_topic_partition_t</a>* rd_kafka_topic_partition_list_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td>
          <td class="paramname"><em>rktparlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find element by <code>topic</code> and <code>partition</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first matching element, or NULL if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="ab72ed92794eabf2e7ba1b7be9c94de1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_topic_partition_list_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td>
          <td class="paramname"><em>rktparlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *a, const void *b, void *opaque)&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort list using comparator <code>cmp</code>. </p>
<p>If <code>cmp</code> is NULL the default comparator will be used that sorts by ascending topic name and partition. </p>

</div>
</div>
<a class="anchor" id="a929ad59ee41ceb4e2f36c8212a5a54ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static RD_INLINE const char* RD_UNUSED rd_kafka_message_errstr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *&#160;</td>
          <td class="paramname"><em>rkmessage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the error string for an errored <a class="el" href="structrd__kafka__message__t.html" title="A Kafka message as returned by the rd_kafka_consume*() family of functions as well as provided to the...">rd_kafka_message_t</a> or NULL if there was no error. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This function MUST NOT be used with the producer. </dd></dl>

</div>
</div>
<a class="anchor" id="a4371deba4afe6941cc5f9e80df5ca3e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int64_t rd_kafka_message_timestamp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *&#160;</td>
          <td class="paramname"><em>rkmessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3">rd_kafka_timestamp_type_t</a> *&#160;</td>
          <td class="paramname"><em>tstype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the message timestamp for a consumed message. </p>
<p>The timestamp is the number of milliseconds since the epoch (UTC).</p>
<p><code>tstype</code> (if not NULL) is updated to indicate the type of timestamp.</p>
<dl class="section return"><dt>Returns</dt><dd>message timestamp, or -1 if not available.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Message timestamps require broker version 0.10.0 or later. </dd></dl>

</div>
</div>
<a class="anchor" id="aba20435b42efef7a3c38dee3fb58c27b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int64_t rd_kafka_message_latency </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *&#160;</td>
          <td class="paramname"><em>rkmessage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the latency for a produced message measured from the produce() call. </p>
<dl class="section return"><dt>Returns</dt><dd>the latency in microseconds, or -1 if not available. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7459bd22e8cfa81aa8c2480a4a0304c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_conf_t* rd_kafka_conf_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create configuration object. </p>
<p>When providing your own configuration to the <code>rd_kafka_*_new_*</code>() calls the rd_kafka_conf_t objects needs to be created with this function which will set up the defaults. I.e.: </p>
<div class="fragment"><div class="line">*   rd_kafka_conf_t *myconf;</div>
<div class="line">*   <a class="code" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a> res;</div>
<div class="line">*</div>
<div class="line">*   myconf = <a class="code" href="rdkafka_8h.html#aa7459bd22e8cfa81aa8c2480a4a0304c">rd_kafka_conf_new</a>();</div>
<div class="line">*   res = <a class="code" href="rdkafka_8h.html#abb1b319278333e8cdee9442da7f135e8">rd_kafka_conf_set</a>(myconf, <span class="stringliteral">&quot;socket.timeout.ms&quot;</span>, <span class="stringliteral">&quot;600&quot;</span>,</div>
<div class="line">*                           errstr, <span class="keyword">sizeof</span>(errstr));</div>
<div class="line">*   <span class="keywordflow">if</span> (res != <a class="code" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4a12343fa082ab52164a17130d6b0d0f5b">RD_KAFKA_CONF_OK</a>)</div>
<div class="line">*      die(<span class="stringliteral">&quot;%s\n&quot;</span>, errstr);</div>
<div class="line">*   </div>
<div class="line">*   rk = <a class="code" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24">rd_kafka_new</a>(..., myconf);</div>
<div class="line">* </div>
</div><!-- fragment --><p>Please see <a class="el" href="CONFIGURATION_8md.html">CONFIGURATION.md</a> for the default settings or use <a class="el" href="rdkafka_8h.html#aa52f3a5a08207e14386739fe336e57be" title="Prints a table to fp of all supported configuration properties, their default values as well as a des...">rd_kafka_conf_properties_show()</a> to provide the information at runtime.</p>
<p>The properties are identical to the Apache Kafka configuration properties whenever possible.</p>
<dl class="section return"><dt>Returns</dt><dd>A new rd_kafka_conf_t object with defaults set.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="rdkafka_8h.html#abb1b319278333e8cdee9442da7f135e8" title="Sets a configuration property. ">rd_kafka_conf_set()</a>, <a class="el" href="rdkafka_8h.html#af3669dacf78c5c0eb536d65cb45d0491" title="Destroys a conf object. ">rd_kafka_conf_destroy()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8cbfe15c6978ff09870e82cb524c673d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_conf_t* rd_kafka_conf_dup </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a copy/duplicate of configuration object <code>conf</code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Interceptors are NOT copied to the new configuration object. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>rd_kafka_interceptor_f_on_conf_dup </dd></dl>

</div>
</div>
<a class="anchor" id="abb1b319278333e8cdee9442da7f135e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a> rd_kafka_conf_set </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>errstr_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a configuration property. </p>
<p><code>conf</code> must have been previously created with <a class="el" href="rdkafka_8h.html#aa7459bd22e8cfa81aa8c2480a4a0304c" title="Create configuration object. ">rd_kafka_conf_new()</a>.</p>
<p>Fallthrough: Topic-level configuration properties may be set using this interface in which case they are applied on the <code>default_topic_conf</code>. If no <code>default_topic_conf</code> has been set one will be created. Any sub-sequent <a class="el" href="rdkafka_8h.html#a138aa4881c8703dd6b69f22ddc454f63">rd_kafka_conf_set_default_topic_conf()</a> calls will replace the current default topic configuration.</p>
<dl class="section return"><dt>Returns</dt><dd><code>rd_kafka_conf_res_t</code> to indicate success or failure. In case of failure <code>errstr</code> is updated to contain a human readable error string. </dd></dl>

</div>
</div>
<a class="anchor" id="a075b15c4141784fdc271de217005a41f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_dr_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(rd_kafka_t *rk, void *payload, size_t len, <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err, void *opaque, void *msg_opaque)&#160;</td>
          <td class="paramname"><em>dr_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>See <a class="el" href="rdkafka_8h.html#ac1c9946aee26e10de2661fcf2242ea8a" title="Producer: Set delivery report callback in provided conf object. ">rd_kafka_conf_set_dr_msg_cb()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac1c9946aee26e10de2661fcf2242ea8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_dr_msg_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(rd_kafka_t *rk, const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *opaque)&#160;</td>
          <td class="paramname"><em>dr_msg_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Producer:</b> Set delivery report callback in provided <code>conf</code> object. </p>
<p>The delivery report callback will be called once for each message accepted by <a class="el" href="rdkafka_8h.html#ae24d8ebf1ea15ed8ea0ea40f74662736" title="Produce and send a single message to broker. ">rd_kafka_produce()</a> (et.al) with <code>err</code> set to indicate the result of the produce request.</p>
<p>The callback is called when a message is succesfully produced or if librdkafka encountered a permanent failure, or the retry counter for temporary errors has been exhausted.</p>
<p>An application must call <a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events. ">rd_kafka_poll()</a> at regular intervals to serve queued delivery report callbacks. </p>

</div>
</div>
<a class="anchor" id="a10db731dc1a295bd9884e4f8cb199311"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_rebalance_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(rd_kafka_t *rk, <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *partitions, void *opaque)&#160;</td>
          <td class="paramname"><em>rebalance_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Consumer:</b> Set rebalance callback for use with coordinated consumer group balancing. </p>
<p>The <code>err</code> field is set to either RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS or RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS and 'partitions' contains the full partition set that was either assigned or revoked.</p>
<p>Registering a <code>rebalance_cb</code> turns off librdkafka's automatic partition assignment/revocation and instead delegates that responsibility to the application's <code>rebalance_cb</code>.</p>
<p>The rebalance callback is responsible for updating librdkafka's assignment set based on the two events: RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS and RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS but should also be able to handle arbitrary rebalancing failures where <code>err</code> is neither of those. </p>
<dl class="section remark"><dt>Remarks</dt><dd>In this latter case (arbitrary error), the application must call rd_kafka_assign(rk, NULL) to synchronize state.</dd></dl>
<p>Without a rebalance callback this is done automatically by librdkafka but registering a rebalance callback gives the application flexibility in performing other operations along with the assinging/revocation, such as fetching offsets from an alternate location (on assign) or manually committing offsets (on revoke).</p>
<dl class="section remark"><dt>Remarks</dt><dd>The <code>partitions</code> list is destroyed by librdkafka on return return from the rebalance_cb and must not be freed or saved by the application.</dd></dl>
<p>The following example shows the application's responsibilities: </p>
<div class="fragment"><div class="line">*    <span class="keyword">static</span> <span class="keywordtype">void</span> rebalance_cb (rd_kafka_t *rk, <a class="code" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> <a class="code" href="structrd__kafka__group__info.html#ad8ad977cc6c3d8bd053afdc88876fd31">err</a>,</div>
<div class="line">*                              <a class="code" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *partitions,</div>
<div class="line">*                              <span class="keywordtype">void</span> *opaque) {</div>
<div class="line">*</div>
<div class="line">*        <span class="keywordflow">switch</span> (err)</div>
<div class="line">*        {</div>
<div class="line">*          <span class="keywordflow">case</span> <a class="code" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba4eab145a6f57f455bdde22cb94b61e90">RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS</a>:</div>
<div class="line">*             <span class="comment">// application may load offets from arbitrary external</span></div>
<div class="line">*             <span class="comment">// storage here and update \p partitions</span></div>
<div class="line">*</div>
<div class="line">*             <a class="code" href="rdkafka_8h.html#a0566419eff2001f8371e3b50aa7d26e9">rd_kafka_assign</a>(rk, partitions);</div>
<div class="line">*             <span class="keywordflow">break</span>;</div>
<div class="line">*</div>
<div class="line">*          <span class="keywordflow">case</span> <a class="code" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba52a7ba59b755f419beec0433cb1633bb">RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS</a>:</div>
<div class="line">*             <span class="keywordflow">if</span> (manual_commits) <span class="comment">// Optional explicit manual commit</span></div>
<div class="line">*                 <a class="code" href="rdkafka_8h.html#ab96539928328f14c3c9177ea0c896c87">rd_kafka_commit</a>(rk, partitions, 0); <span class="comment">// sync commit</span></div>
<div class="line">*</div>
<div class="line">*             <a class="code" href="rdkafka_8h.html#a0566419eff2001f8371e3b50aa7d26e9">rd_kafka_assign</a>(rk, NULL);</div>
<div class="line">*             <span class="keywordflow">break</span>;</div>
<div class="line">*</div>
<div class="line">*          <span class="keywordflow">default</span>:</div>
<div class="line">*             handle_unlikely_error(err);</div>
<div class="line">*             <a class="code" href="rdkafka_8h.html#a0566419eff2001f8371e3b50aa7d26e9">rd_kafka_assign</a>(rk, NULL); <span class="comment">// sync state</span></div>
<div class="line">*             <span class="keywordflow">break</span>;</div>
<div class="line">*         }</div>
<div class="line">*    }</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a1ab8bb9e8d8cdd5906f9e060b506f2eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_offset_commit_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(rd_kafka_t *rk, <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *offsets, void *opaque)&#160;</td>
          <td class="paramname"><em>offset_commit_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Consumer:</b> Set offset commit callback for use with consumer groups. </p>
<p>The results of automatic or manual offset commits will be scheduled for this callback and is served by <a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf" title="Poll the consumer for messages or events. ">rd_kafka_consumer_poll()</a>.</p>
<p>If no partitions had valid offsets to commit this callback will be called with <code>err</code> == RD_KAFKA_RESP_ERR__NO_OFFSET which is not to be considered an error.</p>
<p>The <code>offsets</code> list contains per-partition information:</p>
<ul>
<li><code>offset:</code> committed offset (attempted)</li>
<li><code>err:</code> commit error </li>
</ul>

</div>
</div>
<a class="anchor" id="ace721ef3b7c22d0c111ec747ef039a90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_error_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(rd_kafka_t *rk, int err, const char *reason, void *opaque)&#160;</td>
          <td class="paramname"><em>error_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set error callback in provided conf object. </p>
<p>The error callback is used by librdkafka to signal critical errors back to the application.</p>
<p>If no <code>error_cb</code> is registered then the errors will be logged instead. </p>

</div>
</div>
<a class="anchor" id="a04160826ad039d42c10edec456163fa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_throttle_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)&#160;</td>
          <td class="paramname"><em>throttle_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set throttle callback. </p>
<p>The throttle callback is used to forward broker throttle times to the application for Produce and Fetch (consume) requests.</p>
<p>Callbacks are triggered whenever a non-zero throttle time is returned by the broker, or when the throttle time drops back to zero.</p>
<p>An application must call <a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events. ">rd_kafka_poll()</a> or <a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf" title="Poll the consumer for messages or events. ">rd_kafka_consumer_poll()</a> at regular intervals to serve queued callbacks.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Requires broker version 0.9.0 or later. </dd></dl>

</div>
</div>
<a class="anchor" id="a06ade2ca41f32eb82c6f7e3d4acbe19f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_log_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)&#160;</td>
          <td class="paramname"><em>log_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set logger callback. </p>
<p>The default is to print to stderr, but a syslog logger is also available, see rd_kafka_log_print and rd_kafka_log_syslog for the builtin alternatives. Alternatively the application may provide its own logger callback. Or pass <code>func</code> as NULL to disable logging.</p>
<p>This is the configuration alternative to the deprecated <a class="el" href="rdkafka_8h.html#a9e4af9adee414af74c7817403f7c4a53" title="Set logger function. ">rd_kafka_set_logger()</a></p>
<dl class="section remark"><dt>Remarks</dt><dd>The log_cb will be called spontaneously from librdkafka's internal threads unless logs have been forwarded to a poll queue through <code><a class="el" href="rdkafka_8h.html#a5c8a3be2f797560b2a39bf56dbd7622d" title="Forward librdkafka logs (and debug) to the specified queue for serving with one of the ...">rd_kafka_set_log_queue()</a></code>. An application MUST NOT call any librdkafka APIs or do any prolonged work in a non-forwarded <code>log_cb</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a597d00432e3ca22174d18e7e348fb766"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_stats_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)&#160;</td>
          <td class="paramname"><em>stats_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set statistics callback in provided conf object. </p>
<p>The statistics callback is triggered from <a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events. ">rd_kafka_poll()</a> every <code>statistics.interval.ms</code> (needs to be configured separately). Function arguments:</p>
<ul>
<li><code>rk</code> - Kafka handle</li>
<li><code>json</code> - String containing the statistics data in JSON format</li>
<li><code>json_len</code> - Length of <code>json</code> string.</li>
<li><code>opaque</code> - Application-provided opaque.</li>
</ul>
<p>If the application wishes to hold on to the <code>json</code> pointer and free it at a later time it must return 1 from the <code>stats_cb</code>. If the application returns 0 from the <code>stats_cb</code> then librdkafka will immediately free the <code>json</code> pointer. </p>

</div>
</div>
<a class="anchor" id="a0467a6c20d5af69a29a63b530962ecbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_socket_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(int domain, int type, int protocol, void *opaque)&#160;</td>
          <td class="paramname"><em>socket_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set socket callback. </p>
<p>The socket callback is responsible for opening a socket according to the supplied <code>domain</code>, <code>type</code> and <code>protocol</code>. The socket shall be created with <code>CLOEXEC</code> set in a racefree fashion, if possible.</p>
<p>Default:</p>
<ul>
<li>on linux: racefree CLOEXEC</li>
<li>others : non-racefree CLOEXEC</li>
</ul>
<dl class="section remark"><dt>Remarks</dt><dd>The callback will be called from an internal librdkafka thread. </dd></dl>

</div>
</div>
<a class="anchor" id="a53dd1b77019324170d0168617fdaf040"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_connect_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)&#160;</td>
          <td class="paramname"><em>connect_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set connect callback. </p>
<p>The connect callback is responsible for connecting socket <code>sockfd</code> to peer address <code>addr</code>. The <code>id</code> field contains the broker identifier.</p>
<p><code>connect_cb</code> shall return 0 on success (socket connected) or an error number (errno) on error.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The callback will be called from an internal librdkafka thread. </dd></dl>

</div>
</div>
<a class="anchor" id="ab55c7ddc46a354e3f57b5b209e5ec3c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_closesocket_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(int sockfd, void *opaque)&#160;</td>
          <td class="paramname"><em>closesocket_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set close socket callback. </p>
<p>Close a socket (optionally opened with socket_cb()).</p>
<dl class="section remark"><dt>Remarks</dt><dd>The callback will be called from an internal librdkafka thread. </dd></dl>

</div>
</div>
<a class="anchor" id="a467bb7b1ac070fee536227d6ae9cc551"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_open_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const char *pathname, int flags, mode_t mode, void *opaque)&#160;</td>
          <td class="paramname"><em>open_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set open callback. </p>
<p>The open callback is responsible for opening the file specified by pathname, flags and mode. The file shall be opened with <code>CLOEXEC</code> set in a racefree fashion, if possible.</p>
<p>Default:</p>
<ul>
<li>on linux: racefree CLOEXEC</li>
<li>others : non-racefree CLOEXEC</li>
</ul>
<dl class="section remark"><dt>Remarks</dt><dd>The callback will be called from an internal librdkafka thread. </dd></dl>

</div>
</div>
<a class="anchor" id="a138aa4881c8703dd6b69f22ddc454f63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_default_topic_conf </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_topic_conf_t *&#160;</td>
          <td class="paramname"><em>tconf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the default topic configuration to use for automatically subscribed topics (e.g., through pattern-matched topics). The topic config object is not usable after this call. </p>

</div>
</div>
<a class="anchor" id="abe9f0f77e9145eb1a62c3258ac495b97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a> rd_kafka_conf_get </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>dest_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve configuration value for property <code>name</code>. </p>
<p>If <code>dest</code> is non-NULL the value will be written to <code>dest</code> with at most <code>dest_size</code>.</p>
<p><code>*dest_size</code> is updated to the full length of the value, thus if <code>*dest_size</code> initially is smaller than the full length the application may reallocate <code>dest</code> to fit the returned <code>*dest_size</code> and try again.</p>
<p>If <code>dest</code> is NULL only the full length of the value is returned.</p>
<p>Fallthrough: Topic-level configuration properties from the <code>default_topic_conf</code> may be retrieved using this interface.</p>
<dl class="section return"><dt>Returns</dt><dd><code>RD_KAFKA_CONF_OK</code> if the property name matched, else <code>RD_KAFKA_CONF_UNKNOWN</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a56939e7f77106b9e810d59289443e25d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a> rd_kafka_topic_conf_get </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_topic_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>dest_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve topic configuration value for property <code>name</code>. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="rdkafka_8h.html#abe9f0f77e9145eb1a62c3258ac495b97" title="Retrieve configuration value for property name. ">rd_kafka_conf_get()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6eba851c2af748de6921d708b47dc94c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT const char** rd_kafka_conf_dump </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>cntp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump the configuration properties and values of <code>conf</code> to an array with "key", "value" pairs. </p>
<p>The number of entries in the array is returned in <code>*cntp</code>.</p>
<p>The dump must be freed with <code><a class="el" href="rdkafka_8h.html#a8fee1254096acd17cbd61cfe70d827e5" title="Frees a configuration dump returned from rd_kafka_conf_dump() or `rd_kafka_topic_conf_dump(). ">rd_kafka_conf_dump_free()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a40a7a88bd5ac81b21c45d1fdd4d9e696"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT const char** rd_kafka_topic_conf_dump </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>cntp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump the topic configuration properties and values of <code>conf</code> to an array with "key", "value" pairs. </p>
<p>The number of entries in the array is returned in <code>*cntp</code>.</p>
<p>The dump must be freed with <code><a class="el" href="rdkafka_8h.html#a8fee1254096acd17cbd61cfe70d827e5" title="Frees a configuration dump returned from rd_kafka_conf_dump() or `rd_kafka_topic_conf_dump(). ">rd_kafka_conf_dump_free()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a1a7032f87e7d868b80e38d0fd0ad119e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_topic_conf_t* rd_kafka_topic_conf_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create topic configuration object. </p>
<dl class="section see"><dt>See Also</dt><dd>Same semantics as for <a class="el" href="rdkafka_8h.html#aa7459bd22e8cfa81aa8c2480a4a0304c" title="Create configuration object. ">rd_kafka_conf_new()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac91b47f7733b324bf4159427e90ccd01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a> rd_kafka_topic_conf_set </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>errstr_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a single rd_kafka_topic_conf_t value by property name. </p>
<p><code>topic_conf</code> should have been previously set up with <code><a class="el" href="rdkafka_8h.html#a1a7032f87e7d868b80e38d0fd0ad119e" title="Create topic configuration object. ">rd_kafka_topic_conf_new()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>rd_kafka_conf_res_t to indicate success or failure. </dd></dl>

</div>
</div>
<a class="anchor" id="abfc790b5e36c56ea6d79fdc32c57becf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_topic_conf_set_partitioner_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_conf_t *&#160;</td>
          <td class="paramname"><em>topic_conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t(*)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)&#160;</td>
          <td class="paramname"><em>partitioner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Producer:</b> Set partitioner callback in provided topic conf object. </p>
<p>The partitioner may be called in any thread at any time, it may be called multiple times for the same message/key.</p>
<p>Partitioner function constraints:</p>
<ul>
<li>MUST NOT call any rd_kafka_*() functions except: <a class="el" href="rdkafka_8h.html#ad24c6cc7f37271e292f8105c64d77758" title="Check if partition is available (has a leader broker). ">rd_kafka_topic_partition_available()</a></li>
<li>MUST NOT block or execute for prolonged periods of time.</li>
<li>MUST return a value between 0 and partition_cnt-1, or the special <code>RD_KAFKA_PARTITION_UA</code> value if partitioning could not be performed. </li>
</ul>

</div>
</div>
<a class="anchor" id="ad24c6cc7f37271e292f8105c64d77758"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_topic_partition_available </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if partition is available (has a leader broker). </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the partition is available, else 0.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function must only be called from inside a partitioner function </dd></dl>

</div>
</div>
<a class="anchor" id="ae8690da243d6d22f52cf8a6f0e90d7e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int32_t rd_kafka_msg_partitioner_random </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keylen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg_opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Random partitioner. </p>
<p>Will try not to return unavailable partitions.</p>
<dl class="section return"><dt>Returns</dt><dd>a random partition between 0 and <code>partition_cnt</code> - 1. </dd></dl>

</div>
</div>
<a class="anchor" id="a09edd9204e8fb28dae7a8b000d4492ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int32_t rd_kafka_msg_partitioner_consistent </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keylen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg_opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consistent partitioner. </p>
<p>Uses consistent hashing to map identical keys onto identical partitions.</p>
<dl class="section return"><dt>Returns</dt><dd>a "random" partition between 0 and <code>partition_cnt</code> - 1 based on the CRC value of the key </dd></dl>

</div>
</div>
<a class="anchor" id="a2b79580e110b06ea5434fb71abc0b4eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int32_t rd_kafka_msg_partitioner_consistent_random </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keylen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg_opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consistent-Random partitioner. </p>
<p>This is the default partitioner. Uses consistent hashing to map identical keys onto identical partitions, and messages without keys will be assigned via the random partitioner.</p>
<dl class="section return"><dt>Returns</dt><dd>a "random" partition between 0 and <code>partition_cnt</code> - 1 based on the CRC value of the key (if provided) </dd></dl>

</div>
</div>
<a class="anchor" id="a63d5cd86ab1f77772b2be170e1c09c24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_t* rd_kafka_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831">rd_kafka_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>errstr_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new Kafka handle and starts its operation according to the specified <code>type</code> (<code>RD_KAFKA_CONSUMER</code> or <code>RD_KAFKA_PRODUCER</code>). </p>
<p><code>conf</code> is an optional struct created with <code><a class="el" href="rdkafka_8h.html#aa7459bd22e8cfa81aa8c2480a4a0304c" title="Create configuration object. ">rd_kafka_conf_new()</a></code> that will be used instead of the default configuration. The <code>conf</code> object is freed by this function on success and must not be used or destroyed by the application sub-sequently. See <code><a class="el" href="rdkafka_8h.html#abb1b319278333e8cdee9442da7f135e8" title="Sets a configuration property. ">rd_kafka_conf_set()</a></code> et.al for more information.</p>
<p><code>errstr</code> must be a pointer to memory of at least size <code>errstr_size</code> where <code><a class="el" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24" title="Creates a new Kafka handle and starts its operation according to the specified type (RD_KAFKA_CONSUME...">rd_kafka_new()</a></code> may write a human readable error message in case the creation of a new handle fails. In which case the function returns NULL.</p>
<dl class="section remark"><dt>Remarks</dt><dd><b>RD_KAFKA_CONSUMER:</b> When a new <code>RD_KAFKA_CONSUMER</code> rd_kafka_t handle is created it may either operate in the legacy simple consumer mode using the <a class="el" href="rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4" title="Start consuming messages for topic rkt and partition at offset offset which may either be an absolute...">rd_kafka_consume_start()</a> interface, or the High-level KafkaConsumer API. </dd>
<dd>
An application must only use one of these groups of APIs on a given rd_kafka_t RD_KAFKA_CONSUMER handle.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The Kafka handle on success or NULL on error (see <code>errstr</code>)</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>To destroy the Kafka handle, use <a class="el" href="rdkafka_8h.html#ac052e92621dcaa3a336dbf826e0d7794" title="Destroy Kafka handle. ">rd_kafka_destroy()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac052e92621dcaa3a336dbf826e0d7794"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_destroy </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy Kafka handle. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is a blocking operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a856d7ecba1aa64e5c89ac92b445cdda6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT char* rd_kafka_memberid </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns this client's broker-assigned group member id. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This currently requires the high-level KafkaConsumer</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An allocated string containing the current broker-assigned group member id, or NULL if not available. The application must free the string with <code>free()</code> or <a class="el" href="rdkafka_8h.html#a50178b3d3266c9eeb0b5981377833572" title="Free pointer returned by librdkafka. ">rd_kafka_mem_free()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a261ba8c649756fbc7fbcd442ae481a18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT char* rd_kafka_clusterid </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ClusterId as reported in broker metadata. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_ms</td><td>If there is no cached value from metadata retrieval then this specifies the maximum amount of time (in milliseconds) the call will block waiting for metadata to be retrieved. Use 0 for non-blocking calls.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Requires broker version &gt;=0.10.0 and api.version.request=true.</dd>
<dd>
The application must free the returned pointer using <a class="el" href="rdkafka_8h.html#a50178b3d3266c9eeb0b5981377833572" title="Free pointer returned by librdkafka. ">rd_kafka_mem_free()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated string containing the ClusterId, or NULL if no ClusterId could be retrieved in the allotted timespan. </dd></dl>

</div>
</div>
<a class="anchor" id="ab1dcba74a35e8f3bfe3270ff600581d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_topic_t* rd_kafka_topic_new </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_topic_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new topic handle for topic named <code>topic</code>. </p>
<p><code>conf</code> is an optional configuration for the topic created with <code><a class="el" href="rdkafka_8h.html#a1a7032f87e7d868b80e38d0fd0ad119e" title="Create topic configuration object. ">rd_kafka_topic_conf_new()</a></code> that will be used instead of the default topic configuration. The <code>conf</code> object is freed by this function and must not be used or destroyed by the application sub-sequently. See <code><a class="el" href="rdkafka_8h.html#ac91b47f7733b324bf4159427e90ccd01" title="Sets a single rd_kafka_topic_conf_t value by property name. ">rd_kafka_topic_conf_set()</a></code> et.al for more information.</p>
<p>Topic handles are refcounted internally and calling <a class="el" href="rdkafka_8h.html#ab1dcba74a35e8f3bfe3270ff600581d8" title="Creates a new topic handle for topic named topic. ">rd_kafka_topic_new()</a> again with the same topic name will return the previous topic handle without updating the original handle's configuration. Applications must eventually call <a class="el" href="rdkafka_8h.html#a91f46cd29d4f9abacd3ee3633c01d8ff" title="Loose application&#39;s topic handle refcount as previously created with rd_kafka_topic_new(). ">rd_kafka_topic_destroy()</a> for each succesfull call to <a class="el" href="rdkafka_8h.html#ab1dcba74a35e8f3bfe3270ff600581d8" title="Creates a new topic handle for topic named topic. ">rd_kafka_topic_new()</a> to clear up resources.</p>
<dl class="section return"><dt>Returns</dt><dd>the new topic handle or NULL on error (use <a class="el" href="rdkafka_8h.html#abeabf8589c657d7a3ec5a1411a7de91d" title="Converts the system errno value errnox to a rd_kafka_resp_err_t error code upon failure from the foll...">rd_kafka_errno2err()</a> to convert system <code>errno</code> to an rd_kafka_resp_err_t error code.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="rdkafka_8h.html#a91f46cd29d4f9abacd3ee3633c01d8ff" title="Loose application&#39;s topic handle refcount as previously created with rd_kafka_topic_new(). ">rd_kafka_topic_destroy()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a91f46cd29d4f9abacd3ee3633c01d8ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_topic_destroy </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loose application's topic handle refcount as previously created with <code><a class="el" href="rdkafka_8h.html#ab1dcba74a35e8f3bfe3270ff600581d8" title="Creates a new topic handle for topic named topic. ">rd_kafka_topic_new()</a></code>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Since topic objects are refcounted (both internally and for the app) the topic object might not actually be destroyed by this call, but the application must consider the object destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="ad50c431e3a29d14da534db49bd0682a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_poll </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polls the provided kafka handle for events. </p>
<p>Events will cause application provided callbacks to be called.</p>
<p>The <code>timeout_ms</code> argument specifies the maximum amount of time (in milliseconds) that the call will block waiting for events. For non-blocking calls, provide 0 as <code>timeout_ms</code>. To wait indefinately for an event, provide -1.</p>
<dl class="section remark"><dt>Remarks</dt><dd>An application should make sure to call poll() at regular intervals to serve any queued callbacks waiting to be called.</dd></dl>
<p>Events:</p>
<ul>
<li>delivery report callbacks (if dr_cb/dr_msg_cb is configured) [producer]</li>
<li>error callbacks (<a class="el" href="rdkafka_8h.html#ace721ef3b7c22d0c111ec747ef039a90" title="Set error callback in provided conf object. ">rd_kafka_conf_set_error_cb()</a>) [all]</li>
<li>stats callbacks (<a class="el" href="rdkafka_8h.html#a597d00432e3ca22174d18e7e348fb766" title="Set statistics callback in provided conf object. ">rd_kafka_conf_set_stats_cb()</a>) [all]</li>
<li>throttle callbacks (<a class="el" href="rdkafka_8h.html#a04160826ad039d42c10edec456163fa7" title="Set throttle callback. ">rd_kafka_conf_set_throttle_cb()</a>) [all]</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of events served. </dd></dl>

</div>
</div>
<a class="anchor" id="a111628df6c84716c4b550f8509ac6a6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_yield </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancels the current callback dispatcher (<a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events. ">rd_kafka_poll()</a>, <a class="el" href="rdkafka_8h.html#a303fa0f0da7f3c28bed35570adc983c6" title="Consumes messages from topic rkt and partition, calling the provided callback for each consumed messs...">rd_kafka_consume_callback()</a>, etc). </p>
<p>A callback may use this to force an immediate return to the calling code (caller of e.g. <a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events. ">rd_kafka_poll()</a>) without processing any further events.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This function MUST ONLY be called from within a librdkafka callback. </dd></dl>

</div>
</div>
<a class="anchor" id="a293cb2aac290c157702d3b82f5c14fce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_pause_partitions </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td>
          <td class="paramname"><em>partitions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause producing or consumption for the provided list of partitions. </p>
<p>Success or error is returned per-partition <code>err</code> in the <code>partitions</code> list.</p>
<dl class="section return"><dt>Returns</dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR </dd></dl>

</div>
</div>
<a class="anchor" id="ad05819f26887a916ad2047d96a7b4bf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_resume_partitions </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td>
          <td class="paramname"><em>partitions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume producing consumption for the provided list of partitions. </p>
<p>Success or error is returned per-partition <code>err</code> in the <code>partitions</code> list.</p>
<dl class="section return"><dt>Returns</dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR </dd></dl>

</div>
</div>
<a class="anchor" id="a4550ff7d014f08406666124573f70495"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_query_watermark_offsets </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query broker for low (oldest/beginning) and high (newest/end) offsets for partition. </p>
<p>Offsets are returned in <code>*low</code> and <code>*high</code> respectively.</p>
<dl class="section return"><dt>Returns</dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ad1d338cebde98a76050e61301f631d82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_get_watermark_offsets </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get last known low (oldest/beginning) and high (newest/end) offsets for partition. </p>
<p>The low offset is updated periodically (if statistics.interval.ms is set) while the high offset is updated on each fetched message set from the broker.</p>
<p>If there is no cached offset (either low or high, or both) then RD_KAFKA_OFFSET_INVALID will be returned for the respective offset.</p>
<p>Offsets are returned in <code>*low</code> and <code>*high</code> respectively.</p>
<dl class="section return"><dt>Returns</dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on failure.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Shall only be used with an active consumer instance. </dd></dl>

</div>
</div>
<a class="anchor" id="ae308aaf534807cfd4c71e423fc214929"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_offsets_for_times </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up the offsets for the given partitions by timestamp. </p>
<p>The returned offset for each partition is the earliest offset whose timestamp is greater than or equal to the given timestamp in the corresponding partition.</p>
<p>The timestamps to query are represented as <code>offset</code> in <code>offsets</code> on input, and <code>offset</code> will contain the offset on output.</p>
<p>The function will block for at most <code>timeout_ms</code> milliseconds.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Duplicate Topic+Partitions are not supported. </dd>
<dd>
Per-partition errors may be returned in <code><a class="el" href="structrd__kafka__topic__partition__t.html#ab9370931853903657d7cabc9643d336e">rd_kafka_topic_partition_t.err</a></code> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an error code for general errors, else RD_KAFKA_RESP_ERR_NO_ERROR in which case per-partition errors might be set. </dd></dl>

</div>
</div>
<a class="anchor" id="a50178b3d3266c9eeb0b5981377833572"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_mem_free </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free pointer returned by librdkafka. </p>
<p>This is typically an abstraction for the free(3) call and makes sure the application can use the same memory allocator as librdkafka for freeing pointers returned by librdkafka.</p>
<p>In standard setups it is usually not necessary to use this interface rather than the free(3) functione.</p>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="rdkafka_8h.html#a50178b3d3266c9eeb0b5981377833572" title="Free pointer returned by librdkafka. ">rd_kafka_mem_free()</a> must only be used for pointers returned by APIs that explicitly mention using this function for freeing. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b59178eb7e88d40510a89f3f2d98b44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_queue_t* rd_kafka_queue_new </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new message queue. </p>
<p>See <a class="el" href="rdkafka_8h.html#a8e952d7961169471f69c7ddc87041258" title="Same as rd_kafka_consume_start() but re-routes incoming messages to the provided queue rkqu (which mu...">rd_kafka_consume_start_queue()</a>, <a class="el" href="rdkafka_8h.html#a8ff0b80fccb3a5bd31b1baaf20e4ca16" title="Consume from queue. ">rd_kafka_consume_queue()</a>, et.al. </p>

</div>
</div>
<a class="anchor" id="a9421b3d450f1489cf46f68d49c5ea61e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_queue_destroy </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_queue_t *&#160;</td>
          <td class="paramname"><em>rkqu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a queue, purging all of its enqueued messages. </p>

</div>
</div>
<a class="anchor" id="a7f3d675ee029a52bf85fb28f83c38863"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_queue_t* rd_kafka_queue_get_main </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a reference to the main librdkafka event queue. This is the queue served by <a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events. ">rd_kafka_poll()</a>.</dd></dl>
<p>Use <a class="el" href="rdkafka_8h.html#a9421b3d450f1489cf46f68d49c5ea61e">rd_kafka_queue_destroy()</a> to loose the reference. </p>

</div>
</div>
<a class="anchor" id="acacdb55ae7cb6abfbde89621e512b078"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_queue_t* rd_kafka_queue_get_consumer </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a reference to the librdkafka consumer queue. This is the queue served by <a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf" title="Poll the consumer for messages or events. ">rd_kafka_consumer_poll()</a>.</dd></dl>
<p>Use <a class="el" href="rdkafka_8h.html#a9421b3d450f1489cf46f68d49c5ea61e">rd_kafka_queue_destroy()</a> to loose the reference.</p>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="rdkafka_8h.html#a9421b3d450f1489cf46f68d49c5ea61e">rd_kafka_queue_destroy()</a> MUST be called on this queue prior to calling <a class="el" href="rdkafka_8h.html#a37b54d329e12d745889defe96e7d043d" title="Close down the KafkaConsumer. ">rd_kafka_consumer_close()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad5319a26efb9f843c6029f7dd54b742d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_queue_t* rd_kafka_queue_get_partition </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a reference to the partition's queue, or NULL if partition is invalid.</dd></dl>
<p>Use <a class="el" href="rdkafka_8h.html#a9421b3d450f1489cf46f68d49c5ea61e">rd_kafka_queue_destroy()</a> to loose the reference.</p>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="rdkafka_8h.html#a9421b3d450f1489cf46f68d49c5ea61e">rd_kafka_queue_destroy()</a> MUST be called on this queue</dd>
<dd>
This function only works on consumers. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e2e5571d14636d289f963a270b8e338"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_queue_forward </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_queue_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_queue_t *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forward/re-route queue <code>src</code> to <code>dst</code>. If <code>dst</code> is <code>NULL</code> the forwarding is removed. </p>
<p>The internal refcounts for both queues are increased.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Regardless of whether <code>dst</code> is NULL or not, after calling this function, <code>src</code> will not forward it's fetch queue to the consumer queue. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c8a3be2f797560b2a39bf56dbd7622d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_set_log_queue </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_queue_t *&#160;</td>
          <td class="paramname"><em>rkqu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forward librdkafka logs (and debug) to the specified queue for serving with one of the ..poll() calls. </p>
<pre class="fragment">   This allows an application to serve log callbacks (\c log_cb)
   in its thread of choice.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rkqu</td><td>Queue to forward logs to. If the value is NULL the logs are forwarded to the main queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The configuration property <code>log.queue</code> MUST also be set to true.</dd>
<dd>
librdkafka maintains its own reference to the provided queue.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f24368f4ff0e042907773f532f62e57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT size_t rd_kafka_queue_length </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_queue_t *&#160;</td>
          <td class="paramname"><em>rkqu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the current number of elements in queue. </dd></dl>

</div>
</div>
<a class="anchor" id="acbdd13ab480f6320b2842981eebce784"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_queue_io_event_enable </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_queue_t *&#160;</td>
          <td class="paramname"><em>rkqu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable IO event triggering for queue. </p>
<p>To ease integration with IO based polling loops this API allows an application to create a separate file-descriptor that librdkafka will write <code>payload</code> (of size <code>size</code>) to whenever a new element is enqueued on a previously empty queue.</p>
<p>To remove event triggering call with <code>fd</code> = -1.</p>
<p>librdkafka will maintain a copy of the <code>payload</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>When using forwarded queues the IO event must only be enabled on the final forwarded-to (destination) queue. </dd></dl>

</div>
</div>
<a class="anchor" id="ae21dcd2d8c6195baf7f9f4952d7e12d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_consume_start </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start consuming messages for topic <code>rkt</code> and <code>partition</code> at offset <code>offset</code> which may either be an absolute <code></code>(0..N) or one of the logical offsets: </p>
<ul>
<li>RD_KAFKA_OFFSET_BEGINNING</li>
<li>RD_KAFKA_OFFSET_END</li>
<li>RD_KAFKA_OFFSET_STORED</li>
<li>RD_KAFKA_OFFSET_TAIL</li>
</ul>
<p>rdkafka will attempt to keep <code>queued.min.messages</code> (config property) messages in the local queue by repeatedly fetching batches of messages from the broker until the threshold is reached.</p>
<p>The application shall use one of the <code>rd_kafka_consume*()</code> functions to consume messages from the local queue, each kafka message being represented as a <code><a class="el" href="structrd__kafka__message__t.html" title="A Kafka message as returned by the rd_kafka_consume*() family of functions as well as provided to the...">rd_kafka_message_t</a> *</code> object.</p>
<p><code><a class="el" href="rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4" title="Start consuming messages for topic rkt and partition at offset offset which may either be an absolute...">rd_kafka_consume_start()</a></code> must not be called multiple times for the same topic and partition without stopping consumption first with <code><a class="el" href="rdkafka_8h.html#acf07475e5e85e63fc5321a1087288cd4" title="Stop consuming messages for topic rkt and partition, purging all messages currently in the local queu...">rd_kafka_consume_stop()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on error in which case errno is set accordingly:<ul>
<li>EBUSY - Conflicts with an existing or previous subscription (RD_KAFKA_RESP_ERR__CONFLICT)</li>
<li>EINVAL - Invalid offset, or incomplete configuration (lacking group.id) (RD_KAFKA_RESP_ERR__INVALID_ARG)</li>
<li>ESRCH - requested <code>partition</code> is invalid. (RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION)</li>
<li>ENOENT - topic is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC)</li>
</ul>
</dd></dl>
<p>Use <code><a class="el" href="rdkafka_8h.html#abeabf8589c657d7a3ec5a1411a7de91d" title="Converts the system errno value errnox to a rd_kafka_resp_err_t error code upon failure from the foll...">rd_kafka_errno2err()</a></code> to convert sytem <code>errno</code> to <code>rd_kafka_resp_err_t</code> </p>

</div>
</div>
<a class="anchor" id="a8e952d7961169471f69c7ddc87041258"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_consume_start_queue </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_queue_t *&#160;</td>
          <td class="paramname"><em>rkqu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4" title="Start consuming messages for topic rkt and partition at offset offset which may either be an absolute...">rd_kafka_consume_start()</a> but re-routes incoming messages to the provided queue <code>rkqu</code> (which must have been previously allocated with <code><a class="el" href="rdkafka_8h.html#a2b59178eb7e88d40510a89f3f2d98b44" title="Create a new message queue. ">rd_kafka_queue_new()</a></code>. </p>
<p>The application must use one of the <code>rd_kafka_consume_*_queue()</code> functions to receive fetched messages.</p>
<p><code><a class="el" href="rdkafka_8h.html#a8e952d7961169471f69c7ddc87041258" title="Same as rd_kafka_consume_start() but re-routes incoming messages to the provided queue rkqu (which mu...">rd_kafka_consume_start_queue()</a></code> must not be called multiple times for the same topic and partition without stopping consumption first with <code><a class="el" href="rdkafka_8h.html#acf07475e5e85e63fc5321a1087288cd4" title="Stop consuming messages for topic rkt and partition, purging all messages currently in the local queu...">rd_kafka_consume_stop()</a></code>. <code><a class="el" href="rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4" title="Start consuming messages for topic rkt and partition at offset offset which may either be an absolute...">rd_kafka_consume_start()</a></code> and <code><a class="el" href="rdkafka_8h.html#a8e952d7961169471f69c7ddc87041258" title="Same as rd_kafka_consume_start() but re-routes incoming messages to the provided queue rkqu (which mu...">rd_kafka_consume_start_queue()</a></code> must not be combined for the same topic and partition. </p>

</div>
</div>
<a class="anchor" id="acf07475e5e85e63fc5321a1087288cd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_consume_stop </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop consuming messages for topic <code>rkt</code> and <code>partition</code>, purging all messages currently in the local queue. </p>
<p>NOTE: To enforce synchronisation this call will block until the internal fetcher has terminated and offsets are committed to configured storage method.</p>
<p>The application needs to be stop all consumers before calling <code><a class="el" href="rdkafka_8h.html#ac052e92621dcaa3a336dbf826e0d7794" title="Destroy Kafka handle. ">rd_kafka_destroy()</a></code> on the main object handle.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on error (see <code>errno</code>). </dd></dl>

</div>
</div>
<a class="anchor" id="a6667b162931982e9827e3d86ad22ec7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_seek </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seek consumer for topic+partition to <code>offset</code> which is either an absolute or logical offset. </p>
<p>If <code>timeout_ms</code> is not 0 the call will wait this long for the seek to be performed. If the timeout is reached the internal state will be unknown and this function returns <code>RD_KAFKA_RESP_ERR__TIMED_OUT</code>. If <code>timeout_ms</code> is 0 it will initiate the seek but return immediately without any error reporting (e.g., async).</p>
<p>This call triggers a fetch queue barrier flush.</p>
<dl class="section return"><dt>Returns</dt><dd><code>RD_KAFKA_RESP_ERR__NO_ERROR</code> on success else an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="aa49d14e8b742365f9f25d35318ff0b7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a>* rd_kafka_consume </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consume a single message from topic <code>rkt</code> and <code>partition</code>. </p>
<p><code>timeout_ms</code> is maximum amount of time to wait for a message to be received. Consumer must have been previously started with <code><a class="el" href="rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4" title="Start consuming messages for topic rkt and partition at offset offset which may either be an absolute...">rd_kafka_consume_start()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>a message object on success or <code>NULL</code> on error. The message object must be destroyed with <code><a class="el" href="rdkafka_8h.html#a35e0c519209d1afe9e29468f766c1c24" title="Frees resources for rkmessage and hands ownership back to rdkafka. ">rd_kafka_message_destroy()</a></code> when the application is done with it.</dd></dl>
<p>Errors (when returning NULL):</p>
<ul>
<li>ETIMEDOUT - <code>timeout_ms</code> was reached with no new messages fetched.</li>
<li>ENOENT - <code>rkt</code> + <code>partition</code> is unknown. (no prior <code><a class="el" href="rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4" title="Start consuming messages for topic rkt and partition at offset offset which may either be an absolute...">rd_kafka_consume_start()</a></code> call)</li>
</ul>
<p>NOTE: The returned message's <code></code>..-&gt;err must be checked for errors. NOTE: <code></code>..-&gt;err <code>==</code> <code>RD_KAFKA_RESP_ERR__PARTITION_EOF</code> signals that the end of the partition has been reached, which should typically not be considered an error. The application should handle this case (e.g., ignore).</p>
<dl class="section remark"><dt>Remarks</dt><dd>on_consume() interceptors may be called from this function prior to passing message to application. </dd></dl>

</div>
</div>
<a class="anchor" id="a53511739a2cf498b8d88287fef6873ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT ssize_t rd_kafka_consume_batch </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> **&#160;</td>
          <td class="paramname"><em>rkmessages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rkmessages_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consume up to <code>rkmessages_size</code> from topic <code>rkt</code> and <code>partition</code> putting a pointer to each message in the application provided array <code>rkmessages</code> (of size <code>rkmessages_size</code> entries). </p>
<p><code><a class="el" href="rdkafka_8h.html#a53511739a2cf498b8d88287fef6873ce" title="Consume up to rkmessages_size from topic rkt and partition putting a pointer to each message in the a...">rd_kafka_consume_batch()</a></code> provides higher throughput performance than <code><a class="el" href="rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e" title="Consume a single message from topic rkt and partition. ">rd_kafka_consume()</a></code>.</p>
<p><code>timeout_ms</code> is the maximum amount of time to wait for all of <code>rkmessages_size</code> messages to be put into <code>rkmessages</code>. If no messages were available within the timeout period this function returns 0 and <code>rkmessages</code> remains untouched. This differs somewhat from <code><a class="el" href="rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e" title="Consume a single message from topic rkt and partition. ">rd_kafka_consume()</a></code>.</p>
<p>The message objects must be destroyed with <code><a class="el" href="rdkafka_8h.html#a35e0c519209d1afe9e29468f766c1c24" title="Frees resources for rkmessage and hands ownership back to rdkafka. ">rd_kafka_message_destroy()</a></code> when the application is done with it.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of rkmessages added in <code>rkmessages</code>, or -1 on error (same error codes as for <code><a class="el" href="rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e" title="Consume a single message from topic rkt and partition. ">rd_kafka_consume()</a></code>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e" title="Consume a single message from topic rkt and partition. ">rd_kafka_consume()</a></dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>on_consume() interceptors may be called from this function prior to passing message to application. </dd></dl>

</div>
</div>
<a class="anchor" id="a303fa0f0da7f3c28bed35570adc983c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_consume_callback </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *opaque)&#160;</td>
          <td class="paramname"><em>consume_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consumes messages from topic <code>rkt</code> and <code>partition</code>, calling the provided callback for each consumed messsage. </p>
<p><code><a class="el" href="rdkafka_8h.html#a303fa0f0da7f3c28bed35570adc983c6" title="Consumes messages from topic rkt and partition, calling the provided callback for each consumed messs...">rd_kafka_consume_callback()</a></code> provides higher throughput performance than both <code><a class="el" href="rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e" title="Consume a single message from topic rkt and partition. ">rd_kafka_consume()</a></code> and <code><a class="el" href="rdkafka_8h.html#a53511739a2cf498b8d88287fef6873ce" title="Consume up to rkmessages_size from topic rkt and partition putting a pointer to each message in the a...">rd_kafka_consume_batch()</a></code>.</p>
<p><code>timeout_ms</code> is the maximum amount of time to wait for one or more messages to arrive.</p>
<p>The provided <code>consume_cb</code> function is called for each message, the application <b>MUST</b> <b>NOT</b> call <code><a class="el" href="rdkafka_8h.html#a35e0c519209d1afe9e29468f766c1c24" title="Frees resources for rkmessage and hands ownership back to rdkafka. ">rd_kafka_message_destroy()</a></code> on the provided <code>rkmessage</code>.</p>
<p>The <code>opaque</code> argument is passed to the 'consume_cb' as <code>opaque</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of messages processed or -1 on error.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e" title="Consume a single message from topic rkt and partition. ">rd_kafka_consume()</a></dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>on_consume() interceptors may be called from this function prior to passing message to application. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ff0b80fccb3a5bd31b1baaf20e4ca16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a>* rd_kafka_consume_queue </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_queue_t *&#160;</td>
          <td class="paramname"><em>rkqu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consume from queue. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e" title="Consume a single message from topic rkt and partition. ">rd_kafka_consume()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3d949238471993b18537855aad28fa23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT ssize_t rd_kafka_consume_batch_queue </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_queue_t *&#160;</td>
          <td class="paramname"><em>rkqu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> **&#160;</td>
          <td class="paramname"><em>rkmessages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rkmessages_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consume batch of messages from queue. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="rdkafka_8h.html#a53511739a2cf498b8d88287fef6873ce" title="Consume up to rkmessages_size from topic rkt and partition putting a pointer to each message in the a...">rd_kafka_consume_batch()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abb1aaca2499c2e7d6da37dc28953d532"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_consume_callback_queue </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_queue_t *&#160;</td>
          <td class="paramname"><em>rkqu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *opaque)&#160;</td>
          <td class="paramname"><em>consume_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consume multiple messages from queue with callback. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="rdkafka_8h.html#a303fa0f0da7f3c28bed35570adc983c6" title="Consumes messages from topic rkt and partition, calling the provided callback for each consumed messs...">rd_kafka_consume_callback()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a784186db1d2cb6ceebcd5606d38db4c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_offset_store </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store offset <code>offset</code> for topic <code>rkt</code> partition <code>partition</code>. </p>
<p>The offset will be committed (written) to the offset store according to <code><code>auto.commit.interval.ms</code></code> or manual offset-less commit()</p>
<dl class="section remark"><dt>Remarks</dt><dd><code><code>enable.auto.offset.store</code></code> must be set to "false" when using this API.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a047b1e21236fba30898c7c563c2c6777"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_offsets_store </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store offsets for one or more partitions. </p>
<p>The offset will be committed (written) to the offset store according to <code><code>auto.commit.interval.ms</code></code> or manual offset-less commit().</p>
<p>Per-partition success/error status propagated through each partition's <code></code>.err field.</p>
<dl class="section remark"><dt>Remarks</dt><dd><code><code>enable.auto.offset.store</code></code> must be set to "false" when using this API.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code if none of the offsets could be stored. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ebe15e9d0f39ccc84e9686f0fcf46f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_subscribe </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td>
          <td class="paramname"><em>topics</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscribe to topic set using balanced consumer groups. </p>
<p>Wildcard (regex) topics are supported by the librdkafka assignor: any topic name in the <code>topics</code> list that is prefixed with <code>"^"</code> will be regex-matched to the full list of topics in the cluster and matching topics will be added to the subscription list.</p>
<dl class="section return"><dt>Returns</dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__INVALID_ARG if list is empty, contains invalid topics or regexes. </dd></dl>

</div>
</div>
<a class="anchor" id="ab66a2c014db2e652aa12466b137a6200"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_subscription </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> **&#160;</td>
          <td class="paramname"><em>topics</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current topic subscription. </p>
<dl class="section return"><dt>Returns</dt><dd>An error code on failure, otherwise <code>topic</code> is updated to point to a newly allocated topic list (possibly empty).</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The application is responsible for calling rd_kafka_topic_partition_list_destroy on the returned list. </dd></dl>

</div>
</div>
<a class="anchor" id="a65cc6cb9bd72c4084f074af0361ceddf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a>* rd_kafka_consumer_poll </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Poll the consumer for messages or events. </p>
<p>Will block for at most <code>timeout_ms</code> milliseconds.</p>
<dl class="section remark"><dt>Remarks</dt><dd>An application should make sure to call consumer_poll() at regular intervals, even if no messages are expected, to serve any queued callbacks waiting to be called. This is especially important when a rebalance_cb has been registered as it needs to be called and handled properly to synchronize internal consumer state.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A message object which is a proper message if <code>-&gt;err</code> is RD_KAFKA_RESP_ERR_NO_ERROR, or an event or error for any other value.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>on_consume() interceptors may be called from this function prior to passing message to application.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structrd__kafka__message__t.html" title="A Kafka message as returned by the rd_kafka_consume*() family of functions as well as provided to the...">rd_kafka_message_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a37b54d329e12d745889defe96e7d043d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_consumer_close </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close down the KafkaConsumer. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This call will block until the consumer has revoked its assignment, calling the <code>rebalance_cb</code> if it is configured, committed offsets to broker, and left the consumer group. The maximum blocking time is roughly limited to session.timeout.ms.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An error code indicating if the consumer close was succesful or not.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The application still needs to call <a class="el" href="rdkafka_8h.html#ac052e92621dcaa3a336dbf826e0d7794" title="Destroy Kafka handle. ">rd_kafka_destroy()</a> after this call finishes to clean up the underlying handle resources. </dd></dl>

</div>
</div>
<a class="anchor" id="a0566419eff2001f8371e3b50aa7d26e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_assign </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td>
          <td class="paramname"><em>partitions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic assignment of partitions to consume. </p>
<p>The new <code>partitions</code> will replace the existing assignment.</p>
<p>When used from a rebalance callback the application shall pass the partition list passed to the callback (or a copy of it) (even if the list is empty) rather than NULL to maintain internal join state.</p>
<p>A zero-length <code>partitions</code> will treat the partitions as a valid, albeit empty, assignment, and maintain internal state, while a <code>NULL</code> value for <code>partitions</code> will reset and clear the internal state. </p>

</div>
</div>
<a class="anchor" id="a10a00cc624a46209fe1192cfc56cce59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_assignment </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> **&#160;</td>
          <td class="paramname"><em>partitions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current partition assignment. </p>
<dl class="section return"><dt>Returns</dt><dd>An error code on failure, otherwise <code>partitions</code> is updated to point to a newly allocated partition list (possibly empty).</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The application is responsible for calling rd_kafka_topic_partition_list_destroy on the returned list. </dd></dl>

</div>
</div>
<a class="anchor" id="ab96539928328f14c3c9177ea0c896c87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_commit </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>async</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Commit offsets on broker for the provided list of partitions. </p>
<p><code>offsets</code> should contain <code>topic</code>, <code>partition</code>, <code>offset</code> and possibly <code>metadata</code>. If <code>offsets</code> is NULL the current partition assignment will be used instead.</p>
<p>If <code>async</code> is false this operation will block until the broker offset commit is done, returning the resulting success or error code.</p>
<p>If a <a class="el" href="rdkafka_8h.html#a1ab8bb9e8d8cdd5906f9e060b506f2eb" title="Consumer: Set offset commit callback for use with consumer groups. ">rd_kafka_conf_set_offset_commit_cb()</a> offset commit callback has been configured the callback will be enqueued for a future call to <a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events. ">rd_kafka_poll()</a>, <a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf" title="Poll the consumer for messages or events. ">rd_kafka_consumer_poll()</a> or similar. </p>

</div>
</div>
<a class="anchor" id="a99fb25d50216e4e20d303bf8a4a62883"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_commit_message </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *&#160;</td>
          <td class="paramname"><em>rkmessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>async</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Commit message's offset on broker for the message's partition. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="rdkafka_8h.html#ab96539928328f14c3c9177ea0c896c87" title="Commit offsets on broker for the provided list of partitions. ">rd_kafka_commit</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa793dd9c195f39bcb69465cebf534c47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_commit_queue </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_queue_t *&#160;</td>
          <td class="paramname"><em>rkqu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(rd_kafka_t *rk, <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *offsets, void *opaque)&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Commit offsets on broker for the provided list of partitions. </p>
<p>See rd_kafka_commit for <code>offsets</code> semantics.</p>
<p>The result of the offset commit will be posted on the provided <code>rkqu</code> queue.</p>
<p>If the application uses one of the poll APIs (<a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events. ">rd_kafka_poll()</a>, <a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf" title="Poll the consumer for messages or events. ">rd_kafka_consumer_poll()</a>, <a class="el" href="rdkafka_8h.html#a2f147ed1c554c9048893fb1adde86dfa" title="Poll a queue for an event for max timeout_ms. ">rd_kafka_queue_poll()</a>, ..) to serve the queue the <code>cb</code> callback is required. <code>opaque</code> is passed to the callback.</p>
<p>If using the event API the callback is ignored and the offset commit result will be returned as an RD_KAFKA_EVENT_COMMIT event. The <code>opaque</code> value will be available with <a class="el" href="rdkafka_8h.html#a8650ed2a19108d490a65c9aff3e66525">rd_kafka_event_opaque()</a></p>
<p>If <code>rkqu</code> is NULL a temporary queue will be created and the callback will be served by this call.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="rdkafka_8h.html#ab96539928328f14c3c9177ea0c896c87" title="Commit offsets on broker for the provided list of partitions. ">rd_kafka_commit()</a> </dd>
<dd>
<a class="el" href="rdkafka_8h.html#a1ab8bb9e8d8cdd5906f9e060b506f2eb" title="Consumer: Set offset commit callback for use with consumer groups. ">rd_kafka_conf_set_offset_commit_cb()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a39846ae321a03c4679c9c659f18adf13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_committed </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td>
          <td class="paramname"><em>partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve committed offsets for topics+partitions. </p>
<p>The <code>offset</code> field of each requested partition will either be set to stored offset or to RD_KAFKA_OFFSET_INVALID in case there was no stored offset for that partition.</p>
<dl class="section return"><dt>Returns</dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success in which case the <code>offset</code> or <code>err</code> field of each <code>partitions'</code> element is filled in with the stored offset, or a partition specific error. Else returns an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="a6e9e36bd9e6bf84a9f3092fcbfa3a9ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_position </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&#160;</td>
          <td class="paramname"><em>partitions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve current positions (offsets) for topics+partitions. </p>
<p>The <code>offset</code> field of each requested partition will be set to the offset of the last consumed message + 1, or RD_KAFKA_OFFSET_INVALID in case there was no previous message.</p>
<dl class="section return"><dt>Returns</dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success in which case the <code>offset</code> or <code>err</code> field of each <code>partitions'</code> element is filled in with the stored offset, or a partition specific error. Else returns an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ae24d8ebf1ea15ed8ea0ea40f74662736"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_produce </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>msgflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>keylen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg_opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produce and send a single message to broker. </p>
<p><code>rkt</code> is the target topic which must have been previously created with <code><a class="el" href="rdkafka_8h.html#ab1dcba74a35e8f3bfe3270ff600581d8" title="Creates a new topic handle for topic named topic. ">rd_kafka_topic_new()</a></code>.</p>
<p><code><a class="el" href="rdkafka_8h.html#ae24d8ebf1ea15ed8ea0ea40f74662736" title="Produce and send a single message to broker. ">rd_kafka_produce()</a></code> is an asynch non-blocking API.</p>
<p><code>partition</code> is the target partition, either:</p>
<ul>
<li>RD_KAFKA_PARTITION_UA (unassigned) for automatic partitioning using the topic's partitioner function, or</li>
<li>a fixed partition (0..N)</li>
</ul>
<p><code>msgflags</code> is zero or more of the following flags OR:ed together: RD_KAFKA_MSG_F_BLOCK - block <code>produce*</code>() call if <code>queue.buffering.max.messages</code> or <code>queue.buffering.max.kbytes</code> are exceeded. Messages are considered in-queue from the point they are accepted by produce() until their corresponding delivery report callback/event returns. It is thus a requirement to call <a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events. ">rd_kafka_poll()</a> (or equiv.) from a separate thread when F_BLOCK is used. See WARNING on <code>RD_KAFKA_MSG_F_BLOCK</code> above.</p>
<p>RD_KAFKA_MSG_F_FREE - rdkafka will free(3) <code>payload</code> when it is done with it. RD_KAFKA_MSG_F_COPY - the <code>payload</code> data will be copied and the <code>payload</code> pointer will not be used by rdkafka after the call returns.</p>
<p>.._F_FREE and .._F_COPY are mutually exclusive.</p>
<p>If the function returns -1 and RD_KAFKA_MSG_F_FREE was specified, then the memory associated with the payload is still the caller's responsibility.</p>
<p><code>payload</code> is the message payload of size <code>len</code> bytes.</p>
<p><code>key</code> is an optional message key of size <code>keylen</code> bytes, if non-NULL it will be passed to the topic partitioner as well as be sent with the message to the broker and passed on to the consumer.</p>
<p><code>msg_opaque</code> is an optional application-provided per-message opaque pointer that will provided in the delivery report callback (<code>dr_cb</code>) for referencing this message.</p>
<dl class="section remark"><dt>Remarks</dt><dd>on_send() and on_acknowledgement() interceptors may be called from this function. on_acknowledgement() will only be called if the message fails partitioning.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on error in which case errno is set accordingly:<ul>
<li>ENOBUFS - maximum number of outstanding messages has been reached: "queue.buffering.max.messages" (RD_KAFKA_RESP_ERR__QUEUE_FULL)</li>
<li>EMSGSIZE - message is larger than configured max size: "messages.max.bytes". (RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE)</li>
<li>ESRCH - requested <code>partition</code> is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION)</li>
<li>ENOENT - topic is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC)</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>Use <a class="el" href="rdkafka_8h.html#abeabf8589c657d7a3ec5a1411a7de91d" title="Converts the system errno value errnox to a rd_kafka_resp_err_t error code upon failure from the foll...">rd_kafka_errno2err()</a> to convert <code>errno</code> to rdkafka error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3a111ec3e6729609d498fec7b619efc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_producev </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produce and send a single message to broker. </p>
<p>The message is defined by a va-arg list using <code>rd_kafka_vtype_t</code> tag tuples which must be terminated with a single <code>RD_KAFKA_V_END</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>RD_KAFKA_RESP_ERR_NO_ERROR</code> on success, else an error code.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="rdkafka_8h.html#ae24d8ebf1ea15ed8ea0ea40f74662736" title="Produce and send a single message to broker. ">rd_kafka_produce</a>, <a class="el" href="rdkafka_8h.html#a03c74ceba678b4e7a624310160a02165" title="Convenience macros for rd_kafka_vtype_t that takes the correct arguments for each vtype...">RD_KAFKA_V_END</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7ad15c71f228c47946500a0e5c6f88ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_produce_batch </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>msgflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *&#160;</td>
          <td class="paramname"><em>rkmessages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>message_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produce multiple messages. </p>
<p>If partition is RD_KAFKA_PARTITION_UA the configured partitioner will be run for each message (slower), otherwise the messages will be enqueued to the specified partition directly (faster).</p>
<p>The messages are provided in the array <code>rkmessages</code> of count <code>message_cnt</code> elements. The <code>partition</code> and <code>msgflags</code> are used for all provided messages.</p>
<p>Honoured <code>rkmessages</code>[] fields are:</p>
<ul>
<li>payload,len Message payload and length</li>
<li>key,key_len Optional message key</li>
<li>_private Message opaque pointer (msg_opaque)</li>
<li>err Will be set according to success or failure. Application only needs to check for errors if return value != <code>message_cnt</code>.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of messages succesfully enqueued for producing. </dd></dl>

</div>
</div>
<a class="anchor" id="aaff06c4372bce917c17f3c1a5d8b205d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_flush </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until all outstanding produce requests, et.al, are completed. This should typically be done prior to destroying a producer instance to make sure all queued and in-flight produce requests are completed before terminating. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This function will call <a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events. ">rd_kafka_poll()</a> and thus trigger callbacks.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>RD_KAFKA_RESP_ERR__TIMED_OUT if <code>timeout_ms</code> was reached before all outstanding requests were completed, else RD_KAFKA_RESP_ERR_NO_ERROR </dd></dl>

</div>
</div>
<a class="anchor" id="a84bba4a4b13fdb515f1a22d6fd4f7344"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_metadata </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>all_topics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_topic_t *&#160;</td>
          <td class="paramname"><em>only_rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct rd_kafka_metadata **&#160;</td>
          <td class="paramname"><em>metadatap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request Metadata from broker. </p>
<p>Parameters:</p>
<ul>
<li><code>all_topics</code> if non-zero: request info about all topics in cluster, if zero: only request info about locally known topics.</li>
<li><code>only_rkt</code> only request info about this topic</li>
<li><code>metadatap</code> pointer to hold metadata result. The <code>*metadatap</code> pointer must be released with <a class="el" href="rdkafka_8h.html#a0b4ee98ab1c76f3504edf9eed986844e" title="Release metadata memory. ">rd_kafka_metadata_destroy()</a>.</li>
<li><code>timeout_ms</code> maximum response time before failing.</li>
</ul>
<p>Returns RD_KAFKA_RESP_ERR_NO_ERROR on success (in which case *metadatap) will be set, else RD_KAFKA_RESP_ERR__TIMED_OUT on timeout or other error code on error. </p>

</div>
</div>
<a class="anchor" id="a6cfc79819453ecd4aa94fbae6dbbea0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_list_groups </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrd__kafka__group__list.html">rd_kafka_group_list</a> **&#160;</td>
          <td class="paramname"><em>grplistp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List and describe client groups in cluster. </p>
<p><code>group</code> is an optional group name to describe, otherwise (<code>NULL</code>) all groups are returned.</p>
<p><code>timeout_ms</code> is the (approximate) maximum time to wait for response from brokers and must be a positive value.</p>
<dl class="section return"><dt>Returns</dt><dd><code>RD_KAFKA_RESP_ERR__NO_ERROR</code> on success and <code>grplistp</code> is updated to point to a newly allocated list of groups. Else returns an error code on failure and <code>grplistp</code> remains untouched.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>Use <a class="el" href="rdkafka_8h.html#ab28e1cb749e7e62168107ccdee1960ea" title="Release list memory. ">rd_kafka_group_list_destroy()</a> to release list memory. </dd></dl>

</div>
</div>
<a class="anchor" id="ab83da8da989fe41693d78d982c7ae6b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_brokers_add </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>brokerlist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds one or more brokers to the kafka handle's list of initial bootstrap brokers. </p>
<p>Additional brokers will be discovered automatically as soon as rdkafka connects to a broker by querying the broker metadata.</p>
<p>If a broker name resolves to multiple addresses (and possibly address families) all will be used for connection attempts in round-robin fashion.</p>
<p><code>brokerlist</code> is a ,-separated list of brokers in the format: <code>&lt;broker1&gt;</code>,&lt;broker2&gt;,.. Where each broker is in either the host or URL based format: <code>&lt;host&gt;</code>[:&lt;port&gt;] <code>&lt;proto&gt;</code>://&lt;host&gt;[:port] <code>&lt;proto&gt;</code> is either <code>PLAINTEXT</code>, <code>SSL</code>, <code>SASL</code>, <code>SASL_PLAINTEXT</code> The two formats can be mixed but ultimately the value of the <code>security.protocol</code> config property decides what brokers are allowed.</p>
<p>Example: brokerlist = "broker1:10000,broker2" brokerlist = "SSL://broker3:9000,ssl://broker2"</p>
<dl class="section return"><dt>Returns</dt><dd>the number of brokers successfully added.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Brokers may also be defined with the <code>metadata.broker.list</code> or <code>bootstrap.servers</code> configuration property (preferred method). </dd></dl>

</div>
</div>
<a class="anchor" id="a9e4af9adee414af74c7817403f7c4a53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT RD_DEPRECATED void rd_kafka_set_logger </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set logger function. </p>
<p>The default is to print to stderr, but a syslog logger is also available, see rd_kafka_log_(print|syslog) for the builtin alternatives. Alternatively the application may provide its own logger callback. Or pass 'func' as NULL to disable logging.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>Use <a class="el" href="rdkafka_8h.html#a06ade2ca41f32eb82c6f7e3d4acbe19f" title="Set logger callback. ">rd_kafka_conf_set_log_cb()</a></dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><code>rk</code> may be passed as NULL in the callback. </dd></dl>

</div>
</div>
<a class="anchor" id="acadeefced6bb60acd27e7a0dad553aa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_set_log_level </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the maximum logging level produced by internal kafka logging and debugging. </p>
<p>If the <code>"debug"</code> configuration property is set the level is automatically adjusted to <code>LOG_DEBUG</code> (7). </p>

</div>
</div>
<a class="anchor" id="ad4b3b7659cf9a79d3353810d6b625bb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_outq_len </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current out queue length. </p>
<p>The out queue contains messages waiting to be sent to, or acknowledged by, the broker.</p>
<p>An application should wait for this queue to reach zero before terminating to make sure outstanding requests (such as offset commits) are fully processed.</p>
<dl class="section return"><dt>Returns</dt><dd>number of messages in the out queue. </dd></dl>

</div>
</div>
<a class="anchor" id="a27a46f74ec4ccc9c0b36dbcf546908a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_dump </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps rdkafka's internal state for handle <code>rk</code> to stream <code>fp</code>. </p>
<p>This is only useful for debugging rdkafka, showing state and statistics for brokers, topics, partitions, etc. </p>

</div>
</div>
<a class="anchor" id="a0901699375c972b807ba5255773f017f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_thread_cnt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the current number of threads in use by librdkafka. </p>
<p>Used by regression tests. </p>

</div>
</div>
<a class="anchor" id="aa90f2c92a382dbd0a090d40caa73356d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_wait_destroyed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for all rd_kafka_t objects to be destroyed. </p>
<p>Returns 0 if all kafka objects are now destroyed, or -1 if the timeout was reached.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This function is deprecated. </dd></dl>

</div>
</div>
<a class="anchor" id="ab932d463be030a5e83ebfc5186ff20b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_unittest </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run librdkafka's built-in unit-tests. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of failures, or 0 if all tests passed. </dd></dl>

</div>
</div>
<a class="anchor" id="a9bfa0a1dd3f866cbf0c82fc089bd7904"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_poll_set_consumer </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Redirect the main (<a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events. ">rd_kafka_poll()</a>) queue to the KafkaConsumer's queue (<a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf" title="Poll the consumer for messages or events. ">rd_kafka_consumer_poll()</a>). </p>
<dl class="section warning"><dt>Warning</dt><dd>It is not permitted to call <a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events. ">rd_kafka_poll()</a> after directing the main queue with <a class="el" href="rdkafka_8h.html#a9bfa0a1dd3f866cbf0c82fc089bd7904" title="Redirect the main (rd_kafka_poll()) queue to the KafkaConsumer&#39;s queue (rd_kafka_consumer_poll()). ">rd_kafka_poll_set_consumer()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a108de3729a4aa609a72a458a9de02d1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a8ea376a6d5fe278df583e873109b3c2f">rd_kafka_event_type_t</a> rd_kafka_event_type </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_event_t *&#160;</td>
          <td class="paramname"><em>rkev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the event type for the given event.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>As a convenience it is okay to pass <code>rkev</code> as NULL in which case RD_KAFKA_EVENT_NONE is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a608193d1fb486f78c79497c8c5b63866"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT const char* rd_kafka_event_name </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_event_t *&#160;</td>
          <td class="paramname"><em>rkev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the event type's name for the given event.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>As a convenience it is okay to pass <code>rkev</code> as NULL in which case the name for RD_KAFKA_EVENT_NONE is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="af1835c85aa202caf629861f29f475099"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_event_destroy </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_event_t *&#160;</td>
          <td class="paramname"><em>rkev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy an event. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Any references to this event, such as extracted messages, will not be usable after this call.</dd>
<dd>
As a convenience it is okay to pass <code>rkev</code> as NULL in which case no action is performed. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a855eb7bdf17f5797d4911362a5fc7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a>* rd_kafka_event_message_next </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_event_t *&#160;</td>
          <td class="paramname"><em>rkev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the next message from an event.</dd></dl>
<p>Call repeatedly until it returns NULL.</p>
<p>Event types:</p>
<ul>
<li>RD_KAFKA_EVENT_FETCH (1 message)</li>
<li>RD_KAFKA_EVENT_DR (&gt;=1 message(s))</li>
</ul>
<dl class="section remark"><dt>Remarks</dt><dd>The returned message(s) MUST NOT be freed with <a class="el" href="rdkafka_8h.html#a35e0c519209d1afe9e29468f766c1c24" title="Frees resources for rkmessage and hands ownership back to rdkafka. ">rd_kafka_message_destroy()</a>.</dd>
<dd>
on_consume() interceptor may be called from this function prior to passing message to application. </dd></dl>

</div>
</div>
<a class="anchor" id="a18a17000ebe58eabcdafab37924442b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT size_t rd_kafka_event_message_array </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_event_t *&#160;</td>
          <td class="paramname"><em>rkev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> **&#160;</td>
          <td class="paramname"><em>rkmessages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extacts <code>size</code> message(s) from the event into the pre-allocated array <code>rkmessages</code>. </p>
<p>Event types:</p>
<ul>
<li>RD_KAFKA_EVENT_FETCH (1 message)</li>
<li>RD_KAFKA_EVENT_DR (&gt;=1 message(s))</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of messages extracted.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>on_consume() interceptor may be called from this function prior to passing message to application. </dd></dl>

</div>
</div>
<a class="anchor" id="a61d9d106c8956f379bb77d393b8acf90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT size_t rd_kafka_event_message_count </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_event_t *&#160;</td>
          <td class="paramname"><em>rkev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of remaining messages in the event.</dd></dl>
<p>Event types:</p>
<ul>
<li>RD_KAFKA_EVENT_FETCH (1 message)</li>
<li>RD_KAFKA_EVENT_DR (&gt;=1 message(s)) </li>
</ul>

</div>
</div>
<a class="anchor" id="aa28b7d6bb4885843f9a8b9bafa0e15a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_event_error </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_event_t *&#160;</td>
          <td class="paramname"><em>rkev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the error code for the event.</dd></dl>
<p>Event types:</p>
<ul>
<li>all </li>
</ul>

</div>
</div>
<a class="anchor" id="ad76a1b2d6c4f1727725b075678b88793"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT const char* rd_kafka_event_error_string </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_event_t *&#160;</td>
          <td class="paramname"><em>rkev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the error string (if any). An application should check that <a class="el" href="rdkafka_8h.html#aa28b7d6bb4885843f9a8b9bafa0e15a5">rd_kafka_event_error()</a> returns non-zero before calling this function.</dd></dl>
<p>Event types:</p>
<ul>
<li>all </li>
</ul>

</div>
</div>
<a class="anchor" id="a8650ed2a19108d490a65c9aff3e66525"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void* rd_kafka_event_opaque </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_event_t *&#160;</td>
          <td class="paramname"><em>rkev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the user opaque (if any)</dd></dl>
<p>Event types:</p>
<ul>
<li>RD_KAFKA_OFFSET_COMMIT </li>
</ul>

</div>
</div>
<a class="anchor" id="a535efaa16772642d724bedca414c17c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_event_log </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_event_t *&#160;</td>
          <td class="paramname"><em>rkev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>fac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract log message from the event. </p>
<p>Event types:</p>
<ul>
<li>RD_KAFKA_EVENT_LOG</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 if unsupported event type. </dd></dl>

</div>
</div>
<a class="anchor" id="ae8572e38ffb452f96d13a2d046fb71d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT const char* rd_kafka_event_stats </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_event_t *&#160;</td>
          <td class="paramname"><em>rkev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract stats from the event. </p>
<p>Event types:</p>
<ul>
<li>RD_KAFKA_EVENT_STATS</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>stats json string.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>the returned string will be freed automatically along with the event object </dd></dl>

</div>
</div>
<a class="anchor" id="abc8f98c9b35be497251fb8515e9e6633"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a>* rd_kafka_event_topic_partition_list </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_event_t *&#160;</td>
          <td class="paramname"><em>rkev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the topic partition list from the event.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The list MUST NOT be freed with <a class="el" href="rdkafka_8h.html#a0c0ab2640e5e96113ce108ab78f475d0" title="Free all resources used by the list and the list itself. ">rd_kafka_topic_partition_list_destroy()</a></dd></dl>
<p>Event types:</p>
<ul>
<li>RD_KAFKA_EVENT_REBALANCE</li>
<li>RD_KAFKA_EVENT_OFFSET_COMMIT </li>
</ul>

</div>
</div>
<a class="anchor" id="abf4cce46d6e566dd35865c0451b76afe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="structrd__kafka__topic__partition__t.html">rd_kafka_topic_partition_t</a>* rd_kafka_event_topic_partition </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_event_t *&#160;</td>
          <td class="paramname"><em>rkev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a newly allocated topic_partition container, if applicable for the event type, else NULL.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The returned pointer MUST be freed with <a class="el" href="rdkafka_8h.html#ac5a7b02e3af816cfacbcfa6468c40c9a" title="Destroy a rd_kafka_topic_partition_t. ">rd_kafka_topic_partition_destroy()</a>.</dd></dl>
<p>Event types: RD_KAFKA_EVENT_ERROR (for partition level errors) </p>

</div>
</div>
<a class="anchor" id="a2f147ed1c554c9048893fb1adde86dfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_event_t* rd_kafka_queue_poll </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_queue_t *&#160;</td>
          <td class="paramname"><em>rkqu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Poll a queue for an event for max <code>timeout_ms</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>an event, or NULL.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Use <a class="el" href="rdkafka_8h.html#af1835c85aa202caf629861f29f475099" title="Destroy an event. ">rd_kafka_event_destroy()</a> to free the event. </dd></dl>

</div>
</div>
<a class="anchor" id="a13d80084f20a2800e863b97e465ce98e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_queue_poll_callback </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_queue_t *&#160;</td>
          <td class="paramname"><em>rkqu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Poll a queue for events served through callbacks for max <code>timeout_ms</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of events served.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This API must only be used for queues with callbacks registered for all expected event types. E.g., not a message queue. </dd></dl>

</div>
</div>
<a class="anchor" id="a97bdeb12b99da10eff18767b3cadbfd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_conf_interceptor_add_on_conf_set </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#adb146aa9dbc3a5d4bb4a5b53c1b86b0d">rd_kafka_interceptor_f_on_conf_set_t</a> *&#160;</td>
          <td class="paramname"><em>on_conf_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ic_opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append an on_conf_set() interceptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>Configuration object. </td></tr>
    <tr><td class="paramname">ic_name</td><td>Interceptor name, used in logging. </td></tr>
    <tr><td class="paramname">on_conf_set</td><td>Function pointer. </td></tr>
    <tr><td class="paramname">ic_opaque</td><td>Opaque value that will be passed to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing intercepted with the same <code>ic_name</code> and function has already been added to <code>conf</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a375ce703f6247377305dc6a5dfc84429"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_conf_interceptor_add_on_conf_dup </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#a4339f06d7d4d02d06fbc401d279daeb2">rd_kafka_interceptor_f_on_conf_dup_t</a> *&#160;</td>
          <td class="paramname"><em>on_conf_dup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ic_opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append an on_conf_dup() interceptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>Configuration object. </td></tr>
    <tr><td class="paramname">ic_name</td><td>Interceptor name, used in logging. </td></tr>
    <tr><td class="paramname">on_conf_dup</td><td>Function pointer. </td></tr>
    <tr><td class="paramname">ic_opaque</td><td>Opaque value that will be passed to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing intercepted with the same <code>ic_name</code> and function has already been added to <code>conf</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a919ebd487a2717d6cbdf0d25102ea8ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_conf_interceptor_add_on_conf_destroy </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#a39c5416d05a8262ae0a2937853c99257">rd_kafka_interceptor_f_on_conf_destroy_t</a> *&#160;</td>
          <td class="paramname"><em>on_conf_destroy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ic_opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append an on_conf_destroy() interceptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>Configuration object. </td></tr>
    <tr><td class="paramname">ic_name</td><td>Interceptor name, used in logging. </td></tr>
    <tr><td class="paramname">on_conf_destroy</td><td>Function pointer. </td></tr>
    <tr><td class="paramname">ic_opaque</td><td>Opaque value that will be passed to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Multiple on_conf_destroy() interceptors are allowed to be added to the same configuration object. </dd></dl>

</div>
</div>
<a class="anchor" id="a002ef1d350176725b6e9ba93548edf40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_conf_interceptor_add_on_new </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#a045854635d67e89de3098a0d5f53cc39">rd_kafka_interceptor_f_on_new_t</a> *&#160;</td>
          <td class="paramname"><em>on_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ic_opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append an on_new() interceptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>Configuration object. </td></tr>
    <tr><td class="paramname">ic_name</td><td>Interceptor name, used in logging. </td></tr>
    <tr><td class="paramname">on_send</td><td>Function pointer. </td></tr>
    <tr><td class="paramname">ic_opaque</td><td>Opaque value that will be passed to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Since the on_new() interceptor is added to the configuration object it may be copied by <a class="el" href="rdkafka_8h.html#a8cbfe15c6978ff09870e82cb524c673d" title="Creates a copy/duplicate of configuration object conf. ">rd_kafka_conf_dup()</a>. An interceptor implementation must thus be able to handle the same interceptor,ic_opaque tuple to be used by multiple client instances.</dd>
<dd>
An interceptor plugin should check the return value to make sure it has not already been added.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing intercepted with the same <code>ic_name</code> and function has already been added to <code>conf</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a11b835cb99dc1cfa03c52465b9837a47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_interceptor_add_on_destroy </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#a3eae9c1d37ab4effd55bb8ed5177ac4d">rd_kafka_interceptor_f_on_destroy_t</a> *&#160;</td>
          <td class="paramname"><em>on_destroy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ic_opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append an on_destroy() interceptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rk</td><td>Client instance. </td></tr>
    <tr><td class="paramname">ic_name</td><td>Interceptor name, used in logging. </td></tr>
    <tr><td class="paramname">on_destroy</td><td>Function pointer. </td></tr>
    <tr><td class="paramname">ic_opaque</td><td>Opaque value that will be passed to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing intercepted with the same <code>ic_name</code> and function has already been added to <code>conf</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="af6fb1b8884444c63b6930a7bd6122cb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_interceptor_add_on_send </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#a4b71a63f37c4d94cdb1d05e88f120988">rd_kafka_interceptor_f_on_send_t</a> *&#160;</td>
          <td class="paramname"><em>on_send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ic_opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append an on_send() interceptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rk</td><td>Client instance. </td></tr>
    <tr><td class="paramname">ic_name</td><td>Interceptor name, used in logging. </td></tr>
    <tr><td class="paramname">on_send</td><td>Function pointer. </td></tr>
    <tr><td class="paramname">ic_opaque</td><td>Opaque value that will be passed to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing intercepted with the same <code>ic_name</code> and function has already been added to <code>conf</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="abaf475ab47fff47ab796be1cecbbd370"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_interceptor_add_on_acknowledgement </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#aca93ab41df25cab562b9a4cf6c0e7320">rd_kafka_interceptor_f_on_acknowledgement_t</a> *&#160;</td>
          <td class="paramname"><em>on_acknowledgement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ic_opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append an on_acknowledgement() interceptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rk</td><td>Client instance. </td></tr>
    <tr><td class="paramname">ic_name</td><td>Interceptor name, used in logging. </td></tr>
    <tr><td class="paramname">on_acknowledgement</td><td>Function pointer. </td></tr>
    <tr><td class="paramname">ic_opaque</td><td>Opaque value that will be passed to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing intercepted with the same <code>ic_name</code> and function has already been added to <code>conf</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e722a9930897bba81b33de5fe95b6ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_interceptor_add_on_consume </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#aeafe5c26d64281c1f9a2e2f77f774fa4">rd_kafka_interceptor_f_on_consume_t</a> *&#160;</td>
          <td class="paramname"><em>on_consume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ic_opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append an on_consume() interceptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rk</td><td>Client instance. </td></tr>
    <tr><td class="paramname">ic_name</td><td>Interceptor name, used in logging. </td></tr>
    <tr><td class="paramname">on_consume</td><td>Function pointer. </td></tr>
    <tr><td class="paramname">ic_opaque</td><td>Opaque value that will be passed to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing intercepted with the same <code>ic_name</code> and function has already been added to <code>conf</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d3e29337dbf11762b5a7e492b77b781"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_interceptor_add_on_commit </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#a4ce7c3dfd327ce6512245302be4fe067">rd_kafka_interceptor_f_on_commit_t</a> *&#160;</td>
          <td class="paramname"><em>on_commit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ic_opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append an on_commit() interceptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rk</td><td>Client instance. </td></tr>
    <tr><td class="paramname">ic_name</td><td>Interceptor name, used in logging. </td></tr>
    <tr><td class="paramname">on_commit()</td><td>Function pointer. </td></tr>
    <tr><td class="paramname">ic_opaque</td><td>Opaque value that will be passed to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing intercepted with the same <code>ic_name</code> and function has already been added to <code>conf</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="rdkafka_8h.html">rdkafka.h</a></li>
    <li class="footer">Generated on Thu Aug 3 2017 14:04:47 for librdkafka by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
